#ifndef __GFL_G3DH3DDYNAMICTEXTURE_H__
#define __GFL_G3DH3DDYNAMICTEXTURE_H__
#pragma once

//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
/**
 *	GAME FREAK inc.
 *
 *	@file		gfl_G3dH3dDynamicTexture.h
 *	@brief  H3Dテクスチャ動的生成
 *	@author	Koji Kawada
 *	@date		2012.08.08
 *
 */
//]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]


#if 0
/*説明
このH3dDynamicTextureは
テクスチャのバッファのアドレスからテクスチャのコマンドを生成し保持しておきます。
H3dResTextureのように扱えます。

注意
ダブルバッファの場合は、破棄するタイミングを1フレーム遅らせるようにして下さい。*/
#endif


// CTR_SDK

// NW4C
#include <nw/gfx.h>

// gflib
#include <gfl_Heap.h>
#include <gfl_Macros.h>
#include <gfl_fs.h>

// gflib grp
#include <grp/gfl_GraphicsType.h>

// gflib grp g3d
#include <grp/g3d/gfl_G3dDefine.h>



#if GFL_GRP_G3D_H3D_USE

// NW4C
#include <nw/h3d.h>

// gflib grp g3dh3d



namespace gfl {
namespace grp {
namespace g3d {

//-----------------------------------------------------------------------------
/**
 *					クラス宣言
*/
//-----------------------------------------------------------------------------

//-------------------------------------
///	H3Dテクスチャ動的生成クラス
//=====================================
class H3dDynamicTexture
{
  GFL_FORBID_COPY_AND_ASSIGN(H3dDynamicTexture);


  friend class H3dModel;
  friend class H3dResource;


public:
  // @brief  テクスチャ情報
  struct TextureInformation
  {
    void* physical_address;  // 物理アドレス、VRAMかデバイスメモリ、128バイトアラインメント
                             // nn::gx::CTR::GetPhysicalAddr関数で仮想アドレスから物理アドレスへの変換ができる。
    u16   width;   // 2のべき乗、最小8、最大1024
    u16   height;  // widthと同じルール
    u8    format;  // gfl::grp::g3d::TextureFormat
    u8    mipmap;  // 1=普通の画像1枚だけ; 2=普通の画像1枚と縮小画像1枚; 3=普通の画像1枚と縮小画像2枚;
    u16   dummy;

    TextureInformation(void)  // 構造体風初期化をさせないためだけの目的で用意したコンストラクタ、変数の並び順を変えるかもしれないので。
    {}
  };


public:
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // コンストラクタ / デストラクタ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         コンストラクタ
   */
  //-----------------------------------------------------------------------------
  H3dDynamicTexture(void);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         デストラクタ
   *  
   *  注意
   *  ダブルバッファの場合は、破棄するタイミングを1フレーム遅らせるようにして下さい。
   */
  //-----------------------------------------------------------------------------
  virtual ~H3dDynamicTexture();


  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 生成 / 破棄
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         生成
   */
  //-----------------------------------------------------------------------------
  virtual void Create(gfl::heap::NwAllocator* heap_allocator, gfl::heap::NwAllocator* device_allocator);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         破棄
   *
   *  注意
   *  ダブルバッファの場合は、破棄するタイミングを1フレーム遅らせるようにして下さい。
   */
  //-----------------------------------------------------------------------------
  virtual void Destroy(void);


  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 設定
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         テクスチャ情報を設定する
   *
   *  @param[in]  info  テクスチャ情報
   *                    この関数から戻ってきたら呼び出し元はinfoを破棄しても大丈夫です。
   *
   *  @retval  テクスチャ情報を正常に設定できたときtrueを返す
   */
  //-----------------------------------------------------------------------------
  virtual b32 SetTextureInformation(
      const TextureInformation& info
  );



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 設定 / 取得
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
public:
  void* GetPhysicalAddress(void) const;
  u16   GetWidth(void) const;
  u16   GetHeight(void) const;
  gfl::grp::g3d::TextureFormat GetFormat(void) const;
  u8    GetMipmap(void) const;



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // friendには公開している非公開メンバ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
private:
  // nw::h3d::fndのコマンドを得る
  const nw::h3d::fnd::Command& GetNwCommand(s32 no) const
  {
    return m_cmd_set[no].fnd_cmd;
  }

  // nw::h3d::res::TextureContentを得る
  nw::h3d::res::TextureContent* GetNwTextureContent(void) const
  {
    return m_cont;
  }



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // friendにも公開していない非公開メンバ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
private:
#if 0
/*
CTR
DMPGL2.0システムAPI仕様書
2012-03-14
Ver 3.6
5.8.43 コマンドバッファ実行レジスタ
コマンドバッファのサイズ、アドレスは16バイトアラインでなければならない

CTR プログラミングマニュアル
グラフィックス応用編
2012-03-09
Ver. 4.0
8.1.4 コマンドキャッシュの制限事項および注意事項
? 実行する 3D コマンドバッファのバイトサイズは 16 の倍数でなければなりません。nngxAdd3DCommand() で
0x00000000_00000000 をダミーとして追加することでサイズを調整してください。
*/
#endif

  // @brief  コマンドを扱い易くなるようにセットにしたもの
  struct CmdSet
  {
    enum
    {
      CMD32_NUM_MAX    = 32,  // 32ビットコマンドの個数。実際のコマンドは1個64ビット。
      CMD_ALIGN        = 16   // 16バイトアライン
    };
    bit32*                 cmd;  // cmd[CMD32_NUM_MAX]というふうに使えるようにメモリ確保する。  // 16バイトアラインでデバイスメモリかVRAMにおく。
    u32                    cmd_num;  // 32ビットコマンドの個数。16バイトアラインになるように個数調整して増やしたところには0を入れておけばよい。
    nw::h3d::fnd::Command  fnd_cmd;  // cmdを与えてつくるnw::h3d::fndのコマンド
  };

  // @brief  定数
  enum
  {
    TEX_NO_MAX    = 3,  // テクスチャ番号の個数(0,1,2)(プロシージャルテクスチャは含んでいない)
  };

private:
  // TextureInformationをゼロで初期化する
  static void initializeTextureInformationForZero(TextureInformation* info);
  // TextureInformationに異常がないかチェックする
  static b32 checkTextureInformation(const TextureInformation& info);
  // CmdSetをゼロで初期化する(メモリが確保されていないものとしてゼロ初期化する)
  static void initializeCmdSetForZero(CmdSet* cmd_set);
  // CmdSetをクリアする(メモリが確保されている場合にも確保されていない場合にも対処している)
  static void clearCommand(CmdSet* cmd_set);

  // コンストラクタの中身
  void constructorH3dDynamicTexture(void);
  // 現在のm_infoの内容でコマンドを生成する
  void createCommand(void);

  // nw::h3d::res::TextureContent
  void createTextureContent(gfl::heap::NwAllocator* device_allocator);
  void destroyTextureContent(void);
  void setTextureContent(void);

private:
  TextureInformation  m_info;
  CmdSet  m_cmd_set[TEX_NO_MAX];

  nw::h3d::res::TextureContent* m_cont;
};


}  // namespace g3d
}  // namespace grp
}  // namespace gfl



#endif  // GFL_GRP_G3D_H3D_USE



#endif // __GFL_G3DH3DDYNAMICTEXTURE_H__

