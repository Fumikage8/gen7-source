#ifndef __GFL_G3DH3DANIMATIONSLOT_H__
#define __GFL_G3DH3DANIMATIONSLOT_H__
#pragma once
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
/**
 *	GAME FREAK inc.
 *
 *	@file		gfl_G3dH3dAnimationSlot.h
 *	@brief  H3Dアニメーションスロット
 *	@author	Koji Kawada
 *	@date		2012.04.09
 *
 */
//]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]


#if 0
/*説明
このH3dAnimationSlotでは
nw::h3d::AnimBindState
を扱います。

H3dResAnim*  res_anim;
H3dResAnim** res_anim_list;
H3dResAnim*  m_res_anim;
H3dResAnim** m_res_anim_list;
にconstが付いていないのは、SetFrameでH3dResAnimの値を書き換えるからです。
SetFrameをやめればconstを付けられます。*/

#endif


// CTR_SDK

// NW4C
#include <nw/gfx.h>

// gflib
#include <gfl_Heap.h>
#include <gfl_Macros.h>
#include <gfl_fs.h>

// gflib grp
#include <grp/gfl_GraphicsType.h>

// gflib grp g3d
#include <grp/g3d/gfl_G3dDefine.h>



#if GFL_GRP_G3D_H3D_USE

// NW4C
#include <nw/h3d.h>
// gflib grp g3dh3d
#include <grp/g3d/gfl_G3dH3dResAnim.h>



namespace gfl {
namespace grp {
namespace g3d {

//-----------------------------------------------------------------------------
/**
 *					クラス宣言
*/
//-----------------------------------------------------------------------------


//-------------------------------------
///	クラスの前方宣言
//=====================================
class H3dModel;




//-------------------------------------
///	H3Dアニメーションスロットクラス
//=====================================
class H3dAnimationSlot
{
  GFL_FORBID_COPY_AND_ASSIGN(H3dAnimationSlot);


  friend class H3dAnimationManager;


public:
  // アニメーション変更の結果
  enum ChangeAnimationResult
  {
    CHANGE_ANIMATION_RESULT_OK,                      // 正常
    CHANGE_ANIMATION_RESULT_LIST_INDEX_ERROR,        // 不正なリストインデックス
    CHANGE_ANIMATION_RESULT_DIFFERENT_TYPE,          // スロットを生成したときのタイプと異なる
    CHANGE_ANIMATION_RESULT_OVER_ELEMENT_NUM,        // アニメーション要素数が確保数を越えている
    CHANGE_ANIMATION_RESULT_SOME_ELEMENT_NOT_BOUND,  // いくつかのアニメーション要素がバインドできませんでした。
    CHANGE_ANIMATION_RESULT_ANY_ELEMENT_NOT_BOUND,   // アニメーション要素が 1 つもバインドできませんでした。
    CHANGE_ANIMATION_RESULT_ERROR                    // その他エラー
  };

  // 定数
  enum
  {
    LIST_INDEX_NONE  = -1
  };


public:
  // 設定内容
  struct Description
  {
    AnimationType          type;               // [A優先度高] ANIMATION_TYPE_NONEでないかつ
    u32                    anim_elem_num_max;  // [A優先度高] 0より大のとき[A]が採用されCreateFromAnimElementNumMaxで生成される
    const H3dResAnim*      res_anim;           // [B優先度中] NULLでないとき[B]が採用されCreateFromResAnimで生成される
    s32                    list_max;           // [C優先度低] 0より大かつ
    H3dResAnim**           res_anim_list;      // [C優先度低] NULLでないとき[C]が採用されCreateFromResAnimListで生成される

    Description(void)
      : type(ANIMATION_TYPE_NONE),
        anim_elem_num_max(0),
        res_anim(NULL),
        list_max(0),
        res_anim_list(NULL)
    {}
  };
  void InitializeDescriptionForAnimElementNumMax(Description* desc, AnimationType type, u32 anim_elem_num_max)
  {
    desc->type = type;
    desc->anim_elem_num_max  = anim_elem_num_max;
  }
  void InitializeDescriptionForResAnim(Description* desc, H3dResAnim* res_anim)
  {
    desc->res_anim = res_anim;
  }
  void InitializeDescriptionForResAnimList(Description* desc, s32 list_max, H3dResAnim** res_anim_list)
  {
    desc->list_max = list_max;
    desc->res_anim_list = res_anim_list;
  }



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // friendには公開している非公開メンバ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
private:
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // コンストラクタ / デストラクタ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         コンストラクタ
   */
  //-----------------------------------------------------------------------------
  H3dAnimationSlot(void);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         デストラクタ
   */
  //-----------------------------------------------------------------------------
  virtual ~H3dAnimationSlot();



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 生成 / 破棄
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         生成
   *                 res_anim_listは削除しないで下さい。
   *                 list_maxはres_anim_listの要素数。NULLのところも数に入れておくこと。
   */
  //-----------------------------------------------------------------------------
  b32 Create(gfl::heap::NwAllocator* heap_allocator, H3dModel* model, const Description* desc);
  b32 CreateFromAnimElementNumMax(gfl::heap::NwAllocator* heap_allocator, H3dModel* model, AnimationType type, u32 anim_elem_num_max);
  b32 CreateFromResAnim(gfl::heap::NwAllocator* heap_allocator, H3dModel* model, const H3dResAnim* res_anim);
  b32 CreateFromResAnimList(
      gfl::heap::NwAllocator* heap_allocator,
      H3dModel* model, 
      s32 list_max,
      H3dResAnim** res_anim_list
  );
  //-----------------------------------------------------------------------------
  /**
   *  @brief         破棄
   */
  //-----------------------------------------------------------------------------
  void Destroy(void);



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 計算
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  ///////////////////////////
  // 全部入り
  ///////////////////////////
  //-----------------------------------------------------------------------------
  /**
   *  @brief         計算
   *                 
   *                 この関数が済むとフレームが1つ進んだ状態になります。
   *                 例：
   *                 SetStepFrame(1.0f);
   *                 SetFrame(5.0f);
   *                 f32 f0 = GetFrame();  // f0は5.0fになる。
   *                 Calculate();
   *                 f32 f1 = GetFrame();  // f1は6.0fになる。
   */
  //-----------------------------------------------------------------------------
  void Calculate(void);

  ////////////////////////////////////////////////////////////////////////////////
  // 【注意】全部入りと個別は1フレームにどちらかしか使わないようにして下さい。
  ////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////
  // 個別
  ///////////////////////////
  // ローカルスケルタルアニメーション更新
  void CalculateLocalSkeletalAnimation(void);
  // ビジビリティアニメーション更新
  void CalculateVisibilityAnimation(void);
  // マテリアルアニメーション更新
  void CalculateMaterialAnimation(void);
  // アニメーションフレーム更新
  void CalculateAnimationFrame(void);
  // ワールドスケルタルアニメーション更新
  void CalculateWorldSkeletalAnimation(void);



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 変更
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         変更
   *
   *  @param[in]     res_anim    NULLを設定するとアニメーションを外す(戻り値はCHANGE_ANIMATION_RESULT_OK)。
   *                             スケルタルアニメーションを設定した後NULLを設定すると、・・・？
   *                             マテリアルアニメーションを設定した後NULLを設定すると、マテリアルの変更はそのまま残る。
   *                             ビジビリティアニメーションを設定した後NULLを設定すると、・・・？
   *
   *  @retval        ChangeAnimationResult    次の戻り値を返す場合は、次のような状態になっている。
   *                     CHANGE_ANIMATION_RESULT_OK                       正常
   *                     CHANGE_ANIMATION_RESULT_LIST_INDEX_ERROR         NULLを設定したときと同じ結果になる
   *                     CHANGE_ANIMATION_RESULT_DIFFERENT_TYPE           NULLを設定したときと同じ結果になる
   *                     CHANGE_ANIMATION_RESULT_OVER_ELEMENT_NUM         NULLを設定したときと同じ結果になる
   *                     CHANGE_ANIMATION_RESULT_SOME_ELEMENT_NOT_BOUND   バインドできたものだけアニメーションする
   *                     CHANGE_ANIMATION_RESULT_ANY_ELEMENT_NOT_BOUND    NULLを設定したときと同じ結果になる
   */
  //-----------------------------------------------------------------------------
  ChangeAnimationResult ChangeByResAnim(H3dResAnim* res_anim);
  ChangeAnimationResult ChangeByResAnimListIndex(s32 list_index);

  // bindAnimation関数とunbindAnimation関数はfriendでも使わないで下さい。
  nw::h3d::Result::Description bindAnimation(H3dResAnim* res_anim);
  void unbindAnimation(void);


  //-----------------------------------------------------------------------------
  /**
   *  @brief         今設定されているアニメーションを得る
   *  @retval        アニメーションが設定されていないときはNULLを返す
   *                 H3dResAnimでないアニメーションが設定されているときもNULLを返す
   */
  //-----------------------------------------------------------------------------
  H3dResAnim* GetAnimationAsResAnim(void) const;



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // フレーム
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションのフレームを設定する
   *  @param[in]     frame           フレーム
   */
  //-----------------------------------------------------------------------------
  void SetFrame(f32 frame);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションのフレームを取得する
   *  @retval        フレーム
   */
  //-----------------------------------------------------------------------------
  f32 GetFrame(void) const;

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの更新フレームを設定する
   *                 0.0fで停止、1.0fで等倍、2.0fで2倍速、-1.0fで逆等倍再生
   *
   *  @param[in]     step_frame      更新フレーム
   */
  //-----------------------------------------------------------------------------
  void SetStepFrame(f32 step_frame);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの更新フレームを取得する
   *  @retval        更新フレーム
   */
  //-----------------------------------------------------------------------------
  f32 GetStepFrame(void) const;

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの開始フレームを設定する
   *  @param[in]     frame           フレーム
   */
  //-----------------------------------------------------------------------------
  void SetStartFrame(f32 start_frame);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの開始フレームを取得する
   *  @retval        フレーム
   */
  //-----------------------------------------------------------------------------
  f32 GetStartFrame(void) const;

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの終了フレームを設定する
   *  @param[in]     frame           フレーム
   */
  //-----------------------------------------------------------------------------
  void SetEndFrame(f32 end_frame);
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの終了フレームを取得する
   *  @retval        フレーム
   */
  //-----------------------------------------------------------------------------
  f32 GetEndFrame(void) const;

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの開始フレームと終了フレームを設定する
   *  @param[in]     start_frame     開始フレーム
   *  @param[in]     end_frame       終了フレーム
   */
  //-----------------------------------------------------------------------------
  void SetStartAndEndFrame(f32 start_frame, f32 end_frame);

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの現在のフレームが開始フレームか否か判定する
   *  @retval        bool    現在のフレームが開始フレームの場合tureを返す
   */
  //-----------------------------------------------------------------------------
  b32 IsFrameStartFrame(void) const;
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの現在のフレームが終了フレームか否か判定する
   *  @retval        bool    現在のフレームが終了フレームの場合tureを返す
   */
  //-----------------------------------------------------------------------------
  b32 IsFrameEndFrame(void) const;
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションの現在のフレームが
   *                     step_frame>0のときは終了フレームのときtrueを返す
   *                     step_frame<0のときは開始フレームのときtrueを返す
   *                     step_frame==0のときは開始フレームか終了フレームのときtrueを返し、それ以外のときfalseを返す
   *
   *  @retval        bool    現在のフレームがstep_frameから見て端フレームとなっている場合tureを返す
   *  @note          ループアニメーション時には、終了フレームが設定されないので、trueが返りません。
   */
  //-----------------------------------------------------------------------------
  b32 IsFrameStepTerminalFrame(void) const;

  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションがループ再生か否か取得する
   *                 今設定されているH3dResAnimのループ状態を取得するだけです。
   *  @retval        bool            ループのときtrue、ループでないときfalseを返す
   */
  //-----------------------------------------------------------------------------
  b32 IsLoop(void) const;
  //-----------------------------------------------------------------------------
  /**
   *  @brief         アニメーションにループ再生を設定する
   *                 今設定されているH3dResAnimのループ状態を変更します。
   *  @param[in]     loop            ループのときtrue、ループでないときfalseを設定する
   */
  //-----------------------------------------------------------------------------
  void SetLoop(b32 loop);



  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // friendにも公開していない非公開メンバ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
private:
  // @brief  現在のm_res_animで、フレーム関連の値を初期化する
  void initializeFrame(void);
  // @brief  現在のm_res_animで、現在のフレーム関連の値で、フレームを進める
  void stepFrame(void);
  // @brief  現在のm_res_animで、現在のフレーム関連の値で、フレームを正規化する
  void normalizeFrame(void);

  // @brief  フレームを進めた値を得る
  static f32 staticStepFrame(f32 curr_frame, f32 step_frame, f32 start_frame, f32 end_frame, b32 loop);
  // @brief  フレームを正規化した値を得る
  static f32 staticNormalizeFrame(f32 frame, f32 start_frame, f32 end_frame, b32 loop);
  // @brief  a>bのとき正、a<bのとき負、a==bのとき0を返す。aとbの差がe未満なら==とみなす。
  static s32 COMPARE(f32 a, f32 b, f32 e);

private:
  static const f32 EPSILON = 0.000001f;  // 微小値

private:
  void* m_buff;
  nw::h3d::AnimBindState               m_bind_state;

  H3dModel* m_model;  // 他のところで生成したもののポインタを覚えておくだけ
  AnimationType m_type;
  u32           m_anim_elem_num_max;
 
  H3dResAnim*  m_res_anim;  // 今設定しているアニメーション  // 他のところで生成したもののポインタを覚えておくだけ
  s32          m_list_num;  // m_res_anim_listの要素数
  H3dResAnim** m_res_anim_list;  // 他のところで生成したもののポインタを覚えておくだけ

  // フレーム関連の値
  f32  m_frame;       ///< ユーザーコントロールフレーム
  f32  m_calc_frame;  ///< 実際にアニメーション計算に使用するフレーム
  f32  m_step_frame;
  f32  m_start_frame;
  f32  m_end_frame;
};



}  // namespace g3d
}  // namespace grp
}  // namespace gfl



#endif  // GFL_GRP_G3D_H3D_USE



#endif // __GFL_G3DH3DANIMATIONSLOT_H__

