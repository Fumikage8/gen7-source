#ifndef __GFL_QUEUE_H__
#define __GFL_QUEUE_H__
//========================================================================================
/**
 * @brief  キュー
 * @file   gfl_Queue.h
 * @author obata_toshihiro
 * @date   2011.02.23
 */
//======================================================================================== 
#pragma once

#include <gfl_Heap.h>

namespace gfl {
  namespace base {


    template <class T> class Queue
    {
      public:
        //--------------------------------------------------------------------------------
        /**
         * @brief コンストラクタ
         * 
         * @param heap          キューの生成に使用するヒープ
         * @param max_data_num  キューに登録できるデータの数
         */
        //--------------------------------------------------------------------------------
        Queue( gfl::heap::HeapBase* heap, u32 max_data_num );

        //--------------------------------------------------------------------------------
        /**
         * @brief デストラクタ
         */
        //--------------------------------------------------------------------------------
        ~Queue( void );

        //--------------------------------------------------------------------------------
        /**
         * @brief キューにデータを追加する
         *
         * @param data  追加するデータ
         *
         * @retval true   正しく追加できた
         * @retval false  キューがいっぱいで追加できなかった
         */
        //--------------------------------------------------------------------------------
        bool Enqueue( T data );

        //--------------------------------------------------------------------------------
        /**
         * @brief キューからデータを取り出す
         *
         * @return キューの先頭データ
         *
         * @attention
         * キューが空の場合, 不定値が返ります.
         * IsEmpty()で空かどうかをチェックした上で使用してください.
         */
        //--------------------------------------------------------------------------------
        T Dequeue( void );
    
        //--------------------------------------------------------------------------------
        /**
         * @brief キューの末尾からデータを取り出す
         *
         * @return キューの末尾データ
         *
         * @attention
         * キューが空の場合, 不定値が返ります.
         * IsEmpty()で空かどうかをチェックした上で使用してください.
         */
        //--------------------------------------------------------------------------------
        T DequeueInverse( void );

        //--------------------------------------------------------------------------------
        /**
         * @brief キューのデータを取得する
         * @param data_order  何番目のデータを取得するか
         * @attention キューにつまれている以上のインデックスを指定した場合の戻り値は不定です.
         */
        //--------------------------------------------------------------------------------
        T GetData( u32 data_order ) const;
    
        //--------------------------------------------------------------------------------
        /**
         * @brief キューの末尾データを取得する
         * @attention キューが空の場合の戻り値は不定です.
         */
        //--------------------------------------------------------------------------------
        T GetLastData( void ) const ;

        //--------------------------------------------------------------------------------
        /**
         * @brief キューに登録できるデータの数を取得する
         */
        //--------------------------------------------------------------------------------
        inline u32 GetMaxDataNum( void ) const { return m_max_data_num; }

        //--------------------------------------------------------------------------------
        /**
         * @brief キューに登録されているデータの数を取得する
         */
        //--------------------------------------------------------------------------------
        inline u32 GetDataNum( void ) const { return m_data_num; }

        //--------------------------------------------------------------------------------
        /**
         * @brief キューが空かどうかを調べる
         */
        //--------------------------------------------------------------------------------
        inline bool IsEmpty( void ) const { return ( m_data_num <= 0 ); }

        //--------------------------------------------------------------------------------
        /**
         * @brief キューがいっぱいかどうかを調べる
         */
        //--------------------------------------------------------------------------------
        inline bool IsFull( void ) const { return ( m_max_data_num <= m_data_num ); }

        //--------------------------------------------------------------------------------
        /**
         * @brief キューを空にする
         */
        //--------------------------------------------------------------------------------
        void Clear( void ) { m_data_num = 0; }


      private:
        /**
         * @brief インデックスを計算する
         * 
         * @param data_index  何番目のデータか
         *
         * @return 指定したデータのバッファ上のインデックス
         */
        u32 CalcBufferIndex( u32 data_index ) const;

        T* m_buffer;
        u32 m_max_data_num;
        u32 m_head_pos;
        u32 m_data_num;
    }; 



    //--------------------------------------------------------------------------------
    /**
     * @brief コンストラクタ
     * 
     * @param heap          キューの生成に使用するヒープ
     * @param max_data_num  キューに登録できるデータの数
     */
    //--------------------------------------------------------------------------------
    template <class T> Queue<T>::Queue( gfl::heap::HeapBase* heap, u32 max_data_num ) : 
      m_buffer( GFL_NEW_ARRAY(heap) T[ max_data_num ] ),
      m_max_data_num( max_data_num ),
      m_head_pos( 0 ),
      m_data_num( 0 )
    {
    }

    //--------------------------------------------------------------------------------
    /**
     * @brief デストラクタ
     */
    //--------------------------------------------------------------------------------
    template <class T> Queue<T>::~Queue( void )
    {
      GFL_DELETE_ARRAY m_buffer;
    }

    //--------------------------------------------------------------------------------
    /**
     * @brief キューにデータを追加する
     *
     * @param data  追加するデータ
     *
     * @retval true   正しく追加できた
     * @retval false  キューがいっぱいで追加できなかった
     */
    //--------------------------------------------------------------------------------
    template <class T> bool Queue<T>::Enqueue( T data )
    {
      if( this->IsFull() )
      {
        return false;
      }
      else
      {
        u32 index = CalcBufferIndex( m_data_num );
        m_buffer[ index ] = data;
        m_data_num++;
        return true;
      } 
    }

    /**
     * @brief インデックスを計算する
     * 
     * @param data_index  何番目のデータか
     *
     * @return 指定したデータのバッファ上のインデックス
     */
    template <class T> u32 Queue<T>::CalcBufferIndex( u32 data_index ) const
    {
      return ( m_head_pos + data_index ) % m_max_data_num;
    }

    //--------------------------------------------------------------------------------
    /**
     * @brief キューからデータを取り出す
     *
     * @return キューの先頭データ
     *
     * @attention
     * キューが空の場合, 不定値が返ります.
     * IsEmpty()で空かどうかをチェックした上で使用してください.
     */
    //--------------------------------------------------------------------------------
    template <class T> T Queue<T>::Dequeue( void )
    {
      u32 index = CalcBufferIndex( 0 );
      T& data= m_buffer[ index ]; 

      GFL_ASSERT( !this->IsEmpty() );  //@check
      if( !this->IsEmpty() ) {
        //m_head_pos++;
        m_head_pos = (m_head_pos + 1)%m_max_data_num;
        m_data_num--;
      }
      return data;
    }
    
    //--------------------------------------------------------------------------------
    /**
     * @brief キューの末尾からデータを取り出す
     *
     * @return キューの末尾データ
     *
     * @attention
     * キューが空の場合, 不定値が返ります.
     * IsEmpty()で空かどうかをチェックした上で使用してください.
     */
    //--------------------------------------------------------------------------------
    template <class T> T Queue<T>::DequeueInverse( void )
    {
      GFL_ASSERT( !this->IsEmpty() );  //@check

      u32 index = CalcBufferIndex( m_data_num-1 );
      T& data= m_buffer[ index ]; 

      if( !this->IsEmpty() ) {
        m_data_num--;
      }
      return data;
    }
    
    //--------------------------------------------------------------------------------
    /**
     * @brief キューのデータを取得する
     * @param data_order  何番目のデータを取得するか
     * @attention キューにつまれている以上のインデックスを指定した場合の戻り値は不定です.
     */
    //--------------------------------------------------------------------------------
    template <class T> T Queue<T>::GetData( u32 data_order ) const 
    {
      u32 buffer_index = CalcBufferIndex( data_order );
      return m_buffer[ buffer_index ]; 
    }

    //--------------------------------------------------------------------------------
    /**
     * @brief キューの末尾データを取得する
     * @attention キューが空の場合の戻り値は不定です.
     */
    //--------------------------------------------------------------------------------
    template <class T> T Queue<T>::GetLastData( void ) const 
    {
      u32 buffer_index = 0;
      
      if( this->IsEmpty() == false ){
        buffer_index = CalcBufferIndex( m_data_num-1 );
      }else{
        GFL_ASSERT(0); //@check iwasawa 適切な値を返しようがないので呼び出し元でケアすべき
      }
      return m_buffer[ buffer_index ]; 
    }

  } // namespace base
} // namespace gfl

#endif // __GFL_QUEUE_H__
