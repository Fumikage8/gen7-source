#ifndef __GFL_KEY2CONTAINER_H__
#define __GFL_KEY2CONTAINER_H__
#pragma once
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
/**
 *	GAME FREAK inc.
 *
 *	@file		gfl_Key2Container.h
 *	@brief  キーを2つ持ったコンテナテンプレート
 *	@author	Koji Kawada
 *	@date		2011.06.13
 *
 */
//]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

// CTR_SDK

// NW4C

// gflib
#include <gfl_Macros.h>
#include <gfl_Heap.h>


namespace gfl {
namespace base {

//-----------------------------------------------------------------------------
/**
 *					クラス宣言
*/
//-----------------------------------------------------------------------------

//-------------------------------------
///	キーを2つ持ったコンテナクラス
//  コンストラクタやデストラクタが呼ばれるようなものをK, K2, Tにしないで下さい。
//=====================================
template <typename K, typename K2, typename T> class Key2Container
{
  GFL_FORBID_COPY_AND_ASSIGN(Key2Container);


private:
  struct Key2Data
  {
    K  key;
    K2 key2;
    T  data;
  };


public:

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // コンストラクタ / デストラクタ
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /*
   *  @brief         コンストラクタ
   *                 Createは呼ばれません。
   */
  //-----------------------------------------------------------------------------
  Key2Container(void)
    : m_key2_data_array(NULL),
      m_max_data_num(0),
      m_data_num(0)
  {
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         コンストラクタ
   *                 Createを呼びます。
   *  
   *  @param[in]     heap_meomry   ヒープメモリ
   *  @param[in]     max_data_num  データ数
   */
  //-----------------------------------------------------------------------------
  Key2Container(gfl::heap::HeapBase* heap_memory, const u32 max_data_num)
    : m_key2_data_array(NULL),
      m_max_data_num(max_data_num),
      m_data_num(0)
  {
    Create(heap_memory, max_data_num);
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         デストラクタ
   *                 Destroyを呼びます。
   */
  //-----------------------------------------------------------------------------
  ~Key2Container()
  {
    Destroy();
  }


  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 生成 / 破棄
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /*
   *  @brief         生成
   *  
   *  @param[in]     heap_meomry   ヒープメモリ
   *  @param[in]     max_data_num  データ数
   */
  //-----------------------------------------------------------------------------
  void Create(gfl::heap::HeapBase* heap_memory, const u32 max_data_num)
  {
    GFL_ASSERT_MSG( ( !m_key2_data_array ), "既に生成されています。\n" );  //@check
    
    if( !m_key2_data_array )
    {
      m_max_data_num = max_data_num;

      if( m_max_data_num > 0 )
      {
        m_key2_data_array = GFL_NEW_ARRAY(heap_memory) Key2Data[m_max_data_num];
      }

      m_data_num = 0;
    }
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         破棄
   *                 何回呼んでも大丈夫。デストラクタは呼ばれません。
   */
  //-----------------------------------------------------------------------------
  void Destroy(void)
  {
    if( m_key2_data_array )
    {
      GFL_DELETE_ARRAY m_key2_data_array;
      m_key2_data_array = NULL;
    }
    m_max_data_num = 0;
    m_data_num = 0;
  }


  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 追加 / 削除
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /*
   *  @brief         最後尾にデータを追加
   *  
   *  @param[in]     key   dataのキー
   *  @param[in]     key2  dataのキー2
   *  @param[in]     data  追加するデータ
   *  @retval        b32   追加できたらtrue, 追加できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 AddDataToLast(K key, K2 key2, T data)
  {
    if( m_key2_data_array && m_data_num < m_max_data_num )
    {
      m_key2_data_array[m_data_num].key  = key;
      m_key2_data_array[m_data_num].key2 = key2;
      m_key2_data_array[m_data_num].data = data;
      ++m_data_num;
      return true;
    }
    return false;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         削除
   *  
   *  @param[in]     key   削除するデータのキー
   *  @param[in]     key2  削除するデータのキー2
   *  @retval        b32   削除できたらtrue, 削除できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 RemoveDataByKey(K key, K2 key2)
  {
    if( m_key2_data_array )
    {
      for( u32 i=0; i<m_data_num; ++i )
      {
        if(    m_key2_data_array[i].key  == key
            && m_key2_data_array[i].key2 == key2 )
        {
          for( u32 j=i; j<m_data_num -1; ++j )
          {
            m_key2_data_array[j] = m_key2_data_array[j+1];
          }
          --m_data_num;
          return true;
        }
      }
    }
    return false;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         最後尾のデータを削除
   */
  //-----------------------------------------------------------------------------
  void RemoveLastData(void)
  {
    if( m_data_num > 0 )
    {
      --m_data_num;
    }
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         全削除
   */
  //-----------------------------------------------------------------------------
  void RemoveAllData(void)
  {
    m_data_num = 0;
  }


  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 取得＆削除
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /*
   *  @brief         データを取得した後、削除する
   *  
   *  @param[in]     key   取得するデータのキー
   *  @param[in]     key2  取得するデータのキー2
   *  @param[out]    data  取得したデータ
   *  @retval        b32   削除できたらtrue, 削除できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 GetAndRemoveDataByKey(K key, K2 key2, T* data)
  {
    if( data && m_key2_data_array )
    {
      for( u32 i=0; i<m_data_num; ++i )
      {
        if(    m_key2_data_array[i].key  == key
            && m_key2_data_array[i].key2 == key2 )
        {
          *data = m_key2_data_array[i].data;
          for( u32 j=i; j<m_data_num -1; ++j )
          {
            m_key2_data_array[j] = m_key2_data_array[j+1];
          }
          --m_data_num;
          return true;
        }
      }
    }
    return false;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         最後尾のデータを取得した後、削除する
   *  
   *  @param[out]    key    dataのキー(NULL可)
   *  @param[out]    key2   dataのキー2(NULL可)
   *  @param[out]    data   取得したデータ
   *  @retval        b32    取得できたらtrue, 取得できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 GetAndRemoveLastData(K* key, K2* key2, T* data)
  {
    if( data && m_key2_data_array && m_data_num > 0 )
    {
      if( key )
      {
        *key  = m_key2_data_array[m_data_num -1].key;
      }
      if( key2 )
      {
        *key2 = m_key2_data_array[m_data_num -1].key2;
      }
      *data = m_key2_data_array[m_data_num -1].data;
      --m_data_num;
      return true;
    }
    return false;
  }

  
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 取得
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //-----------------------------------------------------------------------------
  /*
   *  @brief         データを取得する
   *  
   *  @param[in]     key   取得するデータのキー
   *  @param[in]     key2  取得するデータのキー2
   *  @param[out]    data  取得したデータ
   *  @retval        b32   取得できたらtrue, 取得できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 GetDataByKey(K key, K2 key2, T* data) const
  {
    if( data && m_key2_data_array )
    {
      for( u32 i=0; i<m_data_num; ++i )
      {
        if(    m_key2_data_array[i].key  == key
            && m_key2_data_array[i].key2 == key2 )
        {
          *data = m_key2_data_array[i].data;
          return true;
        }
      }
    }
    return false;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         データを取得する
   *  
   *  @param[in]     index  何番目のデータか(0<=index && index<m_data_num)
   *  @param[out]    key    dataのキー(NULL可)
   *  @param[out]    key2   dataのキー2(NULL可)
   *  @param[out]    data   取得したデータ
   *  @retval        b32    取得できたらtrue, 取得できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 GetDataByIndex(const u32 index, K* key, K2* key2, T* data) const
  {
    if( data && m_key2_data_array && /*0<=index &&*/ index<m_data_num )
    {
      if( key )
      {
        *key  = m_key2_data_array[index].key;
      }
      if( key2 )
      {
        *key2 = m_key2_data_array[index].key2;
      }
      *data = m_key2_data_array[index].data;
      return true;
    }
    return false;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         最後尾のデータを取得する
   *  
   *  @param[out]    key    dataのキー(NULL可)
   *  @param[out]    key2   dataのキー2(NULL可)
   *  @param[out]    data   取得したデータ
   *  @retval        b32    取得できたらtrue, 取得できなかったらfalse
   */
  //-----------------------------------------------------------------------------
  b32 GetLastData(K* key, K2* key2, T* data) const
  {
    if( data && m_key2_data_array && m_data_num > 0 )
    {
      if( key )
      {
        *key  = m_key2_data_array[m_data_num -1].key;
      }
      if( key2 )
      {
        *key2 = m_key2_data_array[m_data_num -1].key2;
      }
      *data = m_key2_data_array[m_data_num -1].data;
      return true;
    }
    return false;
  }

  //-----------------------------------------------------------------------------
  /*
   *  @brief         追加できる最大データ数
   *  
   *  @retval        u32  追加できる最大データ数
   */
  //-----------------------------------------------------------------------------
  u32 GetMaxDataNum(void) const
  {
    return m_max_data_num;
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         現在のデータ数
   *  
   *  @retval        u32  現在のデータ数
   */
  //-----------------------------------------------------------------------------
  u32 GetDataNum(void) const
  {
    return m_data_num;
  }

  
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  //
  // 判定
  //
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
 
  //-----------------------------------------------------------------------------
  /*
   *  @brief         空判定
   *  
   *  @retval        b32  データが全くないときtrue, データが1つ以上あるときfalse
   */
  //-----------------------------------------------------------------------------
  b32 IsEmpty(void) const
  {
    return (m_data_num == 0);
  }
  //-----------------------------------------------------------------------------
  /*
   *  @brief         一杯判定
   *  
   *  @retval        b32  データが一杯のときtrue, データに余裕があるときfalse
   */
  //-----------------------------------------------------------------------------
  b32 IsFull(void) const
  {
    return (m_data_num == m_max_data_num);
  }


private:
  Key2Data*  m_key2_data_array;
  u32        m_max_data_num;
  u32        m_data_num;
};


}  // namespace base
}  // namespace gfl

#endif // __GFL_KEY2CONTAINER_H__
