//============================================================================================
/**
 *	GAME FREAK inc.
 * @file    gfl_MathCoded.cpp
 * @brief   暗号関数
 * @author  k.ohno
 * @date    2010.12.16
 */
//============================================================================================

#include <nn/math.h>
#include "gfl_Std.h"
#include "math/gfl_MathCoded.h"



namespace gfl{
namespace math{

//-----------------------------------------------------------------------------
//
//  ここにある暗号ルーチンはWBまでのものと同一である
//
//-----------------------------------------------------------------------------
  
//-----------------------------------------------------------------------------
/**
 * @brief               乱数暗号キー生成ルーチン
  線形合同法
  add=24691は独自のようである 文献を見つけることができなかった
 * @param[in,out] code  暗号キー格納ワークのポインタ
 * @return              暗号キー格納ワークの上位2バイトを暗号キーとして返す
 */
//-----------------------------------------------------------------------------
static  u16 CodeRand(u32 *code)
{
  code[0] = code[0] *1103515245L + 24691;
  return static_cast<u16>(code[0] >> 16) ;
}

//-----------------------------------------------------------------------------
/**
 * @brief   チェックサムの算出ルーチン
 * @param adrs  開始アドレス
 * @param size  データサイズ
 * @retval  "算出した値"
 */
//-----------------------------------------------------------------------------
u32 CheckSum(const void * adrs, u32 size)
{
  u32 sum, ofs;
  const u8* ad8 = reinterpret_cast<const u8*>(adrs);

  sum = 0;
  for (ofs = 0; ofs < size; ofs ++){
    sum += ad8[ofs];
  }
  return sum;
}

//-----------------------------------------------------------------------------
/**
 *  @brief   暗号処理
 * @param[in] data  暗号化するデータのポインタ
 * @param[in] size  暗号化するデータのサイズ
 * @param[in] code  暗号化キーの初期値
 */
//-----------------------------------------------------------------------------
void KeyStreamCoded(void *data,u32 size,u32 code)
{
  int i;
  u16 *data_p = static_cast<u16 *>(data);

  //暗号は、乱数暗号キーでマスク
  for(i=0;i<size/2;i++){
    data_p[i]^=CodeRand(&code);
  }
}

//-----------------------------------------------------------------------------
/**
 *  @brief   復号処理
 * @param[in] data  復号するデータのポインタ
 * @param[in] size  復号するデータのサイズ
 * @param[in] code  暗号化キーの初期値
 */
//-----------------------------------------------------------------------------
void  KeyStreamDecoded(void *data,u32 size,u32 code)
{
  /// 今は同じ関数だが、暗号を変更した場合には同じでないことも考えられるので記述
  KeyStreamCoded(data,size,code);
}

}//math
}//gfl
