//===========================================================================
/**
 * @file    gfl2_StrSys.h
 * @brief   GAMEFREAK Library String System ( 文字列処理システムコア )
 * @author  GAMEFREAK inc.
 * @date    2010.11.12
 */
//===========================================================================
#if !defined( GFL2_STRSYS_H_INCLUDED )
#define GFL2_STRSYS_H_INCLUDED
#pragma once

#include <stdlib.h>
#include <types/include/gfl2_Typedef.h>
#include <macro/include/gfl2_Macros.h>

GFL_NAMESPACE_BEGIN(gfl2)
GFL_NAMESPACE_BEGIN(str)

//--------------------------------------------------------------
/**
 *  文字コード設定
 */
//--------------------------------------------------------------
#define _GFL_STRCODE_SJIS    (0)
#define _GFL_STRCODE_UTF16   (1)
#define _GFL_STRCODE   _GFL_STRCODE_UTF16

//--------------------------------------------------------------
/**
 *  文字コード型＆リテラル定義用マクロ
 */
//--------------------------------------------------------------
#if _GFL_STRCODE == _GFL_STRCODE_UTF16

  typedef  wchar_t  STRCODE;
  #define  GFLSTR(s)  L ## s

#else

  typedef  char      STRCODE;
  #define  GFLSTR(s) s

#endif  // #if _GFL_STRCODE == _GFL_STRCODE_UTF16

//--------------------------------------------------------------
/**
 *  特殊文字コード定義
 */
//--------------------------------------------------------------
enum {
  EOM_CODE       = GFLSTR('\0'),  ///< 終端文字コード
  CR_CODE        = 0x000a,        ///< 改行文字コード
  TAG_START_CODE = 0x0010,        ///< タグ開始文字コード
  TAG_USER_NULL  = 0x0000,        ///< ユーザータグ無効値（これと同じユーザータグを使ってはいけません）

  /*
   *  GFL-CPP の文字列タグフォーマットについて
   *
   *  文字列中にタグを埋め込むことで、様々な拡張処理（文字色の変更、ウェイトの変更、SE再生、等々）を可能にします。
   *  どのようなタグを用意・実装するかはプロジェクトごとに任意ですが、最低限、以下のフォーマットに従う必要があります。
   *
   *  1. タグは TAG_START_CODE で始まる。
   *     gflib::str クラス＆関数群は、文字列中にこのコードがある個所からタグ記述が開始されていると解釈します。
   *
   *
   *  2. TAG_START_CODE の次の要素は、以降に続くユーザータグ＆引数の合計要素数。（１以上）
   *
   *     例えば文字列の描画座標を変更するためのユーザータグ USERTAG_CHANGEPOS というのを用意したい場合、
   *     そのタグには、新たな x, y 座標を指定するために引数が２つ必要になるかと思います。
   *     このタグを使って、描画座標を ( 0, 20 ) へ切り替えたい場合は以下のような文字列を用意することになります。
   *
   *     ----------------------------------------------------------------------------------------
   *     ..., [通常文字], TAG_START_CODE, 3, USERTAG_CHANGEPOS, 0, 20, [通常文字], ...
   *                                     ^^^
   *     ----------------------------------------------------------------------------------------
   *
   *     この例の '3' は、以降に続いている [USERTAG_CHANGEPOS, 0, 20] というユーザータグ＆引数の要素数です。
   *
   *
   *  2010.11.12  Masao Taya
   */
};


//--------------------------------------------------------------
/**
 *  その他定数定義
 */
//--------------------------------------------------------------
enum {
  WARNING_LENGTH = 2048,    ///< 文字列の長さがこの値を超えていたら警告。無限ループ回避の基準などにも使用する。
  NUM_TAG_PARAM_MAX = 16,   ///< タグ引数の最大個数
};

//==========================================================================================
//==========================================================================================
//========================================================================
/**
 * 文字列の長さ（終端文字を含まない）を返す
 *
 * @param[in]    str    文字列ポインタ
 *
 * @retval  u32   文字列の長さ
 */
//========================================================================
u32 StrLen( const STRCODE* str );

//========================================================================
/**
 * 文字列コピー
 *
 * @param[out]   dst    コピー先の文字配列
 * @param[in]    src    コピー元の文字配列
 *
 * @retval  u32   コピーした文字数（終端文字を含まない）
 */
//========================================================================
u32 StrCopy( STRCODE* dst, const STRCODE* src );

//========================================================================
/**
 * 文字列コピー（最大文字数の指定あり）
 *
 * @param[out]   dst          コピー先の文字配列
 * @param[in]    src          コピー元の文字配列
 * @param[in]    numCharMax   コピーする最大文字数
 *
 * @retval  u32   コピーした文字数（終端文字を含まない）
 */
//========================================================================
u32 StrNCopy( STRCODE* dst, const STRCODE* src, u32 numCharMax );


//========================================================================
/**
 * 文字列比較
 *
 * @param[in]    s1       比較用文字列１
 * @param[in]    s2       比較用文字列２
 *
 * @retval  bool    s1, s2 の内容が一致していたらTRUEを返す
 */
//========================================================================
bool StrComp( const STRCODE* s1, const STRCODE* s2 );

//========================================================================
/**
 * 行数カウント
 *
 * @param[in]      str      文字列ポインタ
 *
 * @retval  u32    行数
 */
//========================================================================
u32 CountLines( const STRCODE* str );

//========================================================================
/**
 * 指定行の文字列長（終端文字・改行文字を含まない）を取得する
 *
 * @param[in]   str       文字列ポインタ
 * @param[in]   lineIdx   行番号（0〜）
 *
 * @retval  u32   lineIdxで指定された行の文字列長
 */
//========================================================================
u32 LineLen( const STRCODE* str, u32 lineIdx );


//========================================================================
/**
 * 指定行の先頭ポインタを取得
 *
 * @param[in]   str       文字列ポインタ
 * @param[in]   lineIdx   行番号（0〜）
 *
 * @retval  u32   lineIdxで指定された行の先頭文字ポインタ
 */
//========================================================================
const STRCODE* GetLinePtr( const STRCODE* str, u32 lineIdx );

//========================================================================
/**
 * 指定行の文字列をコピー
 *
 * @param[out]    dst       コピー先の文字配列
 * @param[in]     dstSize   コピー元の文字配列 要素数
 * @param[in]     src       コピー元の文字配列
 * @param[in]     lineIdx   行番号（0〜）
 *
 * @retval  u32   コピーした文字数（終端文字を含まない）
 */
//========================================================================
u32 LineCopy( STRCODE* dst, u32 dstSize, const STRCODE* src, u32 lineIdx );

//========================================================================
/**
 * タグ開始コード〜引数部分をスキップした文字列ポインタを返す
 *
 * @param[in]   str   文字列ポインタ（タグ開始コードを指していること）
 *
 * @retval  wchar_t*  タグ開始コード〜タグ引数部をスキップした文字列ポインタ
 */
//========================================================================
const STRCODE* SkipTagCode( const STRCODE* str );

//========================================================================
/**
 * ユーザータグコードを取得
 *
 * @param[in]   str       文字列ポインタ（タグ開始コードを指していること）
 *
 * @retval  u16   タグコード
 */
//========================================================================
u16 GetTagCode( const STRCODE* str );

//--------------------------------------------------------------
/**
 * タグ引数の個数を取得
 *
 * @param[in]   str   文字列ポインタ（タグ開始コードを指していること）
 *
 * @retval  u16   タグ引数の個数
 */
//--------------------------------------------------------------
u16 GetTagParamCount( const STRCODE* str );

//========================================================================
/**
 * タグ引数を取得
 *
 * @param[in]   str       文字列ポインタ（タグ開始コードを指していること）
 * @param[in]   paramIdx  パラメータIndex（0〜）
 *
 * @retval  u16   タグ引数s
 */
//========================================================================
u16 GetTagParam( const STRCODE* str, u32 paramIdx );


//--------------------------------------------------------------
/**
 * 文字コード Print （デバッグ用）
 *
 * @param[in]     str       文字列ポインタ
 * @param[in]     caption   文字列の前にPrintするキャプション（任意）
 */
//--------------------------------------------------------------
void PrintCode( const STRCODE* str, const char* caption = NULL );


//============================================================================================
// 規定の文字コード用以外にも必要になりそうな関数群
//============================================================================================

/**
 * 文字列比較（タグを考慮しない）
 *
 * @param[in]    s1       比較用文字列１
 * @param[in]    s2       比較用文字列２
 *
 * @retval  bool    s1, s2 の内容が一致していたらTRUEを返す
 */
bool StrComp_J( const char* s1, const char* s2 );
bool StrComp_U( const wchar_t* s1, const wchar_t* s2 );


GFL_NAMESPACE_END(str)
GFL_NAMESPACE_END(gfl2)

#endif // GFL2_STRSYS_H_INCLUDED
