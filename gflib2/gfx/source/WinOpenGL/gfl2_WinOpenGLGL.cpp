#include <string>
#if !defined(NOMINMAX)
#define NOMINMAX
#endif
#include <windows.h>

#include <debug/include/gfl2_Assert.h>

#include <gfx/include/gfl2_GLMemory.h>
#include <gfx/include/gfl2_GFGLUtil.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLTypes.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLGL.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLConstantBuffer.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLSurface.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLVertexShader.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLGeometryShader.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLPixelShader.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLVertexBuffer.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLIndexBuffer.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLStateObject.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLTexture.h>
#include <gfx/include/WinOpenGL/gfl2_WinOpenGLQueryObject.h>

#include <vector>
#include <sstream>

#include <system/include/Timer/gfl2_PerformanceCounter.h>

typedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC) (int interval);

namespace gfl2 { namespace gfx { namespace winOpenGL {

//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
//  グローバル
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
static const char* s_szRegName = "gfl2.gfx.WinOpenGL";
static const HINSTANCE s_hInstance = GetModuleHandle( NULL );

static const u32 sc_windowWidthUp = 400;    // ディスプレイバッファ：幅：上画面
static const u32 sc_windowHeightUp = 240;   // ディスプレイバッファ：高さ：上画面

static const u32 sc_windowWidthDown = 320;  // ディスプレイバッファ：幅：下画面
static const u32 sc_windowHeightDown = 240; // ディスプレイバッファ：高さ：下画面

static const u32 sc_windowWidthUpDown = sc_windowWidthUp;                         // ディスプレイバッファ：幅
static const u32 sc_windowHeightUpDown = sc_windowHeightUp + sc_windowHeightDown; // ディスプレイバッファ：高さ

static const u32 sc_frameBufferWidth = 512; // フレームバッファ：幅
static const u32 sc_frameBufferHeight = 256; // フレームバッファ：高さ


WinOpenGLGL				*WinOpenGLGL::s_Gp = NULL;

class StringUtil{
public:
	static std::wstring ShitJIStoUTF16( const std::string& str )
	{
		int len = ::MultiByteToWideChar( CP_ACP, 0, str.c_str(), -1, NULL, 0 );

		if ( len > 0 ) { 
			std::vector<wchar_t> utf16( len );

			if ( ::MultiByteToWideChar( CP_ACP, 0, str.c_str(), -1, &utf16[0], len ) ){
				return std::wstring( &utf16[0] );
			}
		}

		return NULL;
	}
};

//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
//! @brief  ディスプレイウィンドウクラス
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
class DisplayWindow: public GLMemory
{
public:
  DisplayMode					m_DisplayMode;
  float								m_Aspect;
  bool								m_AutoDestroyWindow;

  HWND								m_hWnd;
	HDC									m_hdc;
	HGLRC								m_RenderContext;

	GLuint							m_FrameBufferID;

	Surface							*m_pRenderTarget;
	Texture							*m_pDepthStencil;

	DisplayWindow( HWND hWnd, HDC hdc, HGLRC renderContext, DisplayMode displayMode ) : GLMemory()
	{
		m_hWnd = hWnd;
    m_hdc = hdc;
    m_RenderContext = renderContext;

		m_DisplayMode = displayMode;
		m_Aspect = 0.0f;
		m_AutoDestroyWindow = false;
	}

	b32 Init()
	{
		glGenFramebuffers( 1, &m_FrameBufferID );

		return true;
	}

	virtual ~DisplayWindow( void )
	{
    glDeleteFramebuffers(1, &m_FrameBufferID);

		delete m_pRenderTarget;
		delete m_pDepthStencil;

		wglDeleteContext( m_RenderContext );

		//  ディスプレイウィンドウを削除
		if( m_AutoDestroyWindow == true )
			::DestroyWindow( m_hWnd );
	}

  u32 GetCtrDisplayNo()
  {
    return m_DisplayMode - DisplayMode::CTR_LEFT;
  }
};

//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
//! @brief  WinOpenGLGLクラス
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
LRESULT CALLBACK WinOpenGLGL::MainWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
	switch(msg)
	{
	case WM_CLOSE:
		PostQuitMessage( 0 );
		break;
	case WM_KEYDOWN:
		if( wParam == VK_ESCAPE ){
			SendMessage( hWnd, WM_CLOSE, 0, 0 );
		}
		break;
	}

	return DefWindowProc(hWnd, msg, wParam, lParam);
}

void APIENTRY WinOpenGLGL::GlDebugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, void* userParam)
{
  (void)length;
  (void)userParam;

  std::stringstream ss;
  ss << "---------------------OpenGL DebugCallback Begin------------" << std::endl;
  ss << "message: "<< message << std::endl;

  ss << "source: ";
  switch (source) {
  case GL_DEBUG_SOURCE_API:
    ss << "API -> 'Calls to the OpenGL API'";
    break;
  case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
    ss << "WINDOW_SYSTEM -> 'Calls to a window-system API'";
    break;
  case GL_DEBUG_SOURCE_SHADER_COMPILER:
    ss << "SHADER_COMPILER -> 'A compiler for a shading language'";
    break;
  case GL_DEBUG_SOURCE_THIRD_PARTY:
    ss << "THIRD_PARTY -> 'An application associated with OpenGL'";
    break;
  case GL_DEBUG_SOURCE_APPLICATION:
    ss << "APPLICATION -> 'Generated by the user of this application'";
    break;
  case GL_DEBUG_SOURCE_OTHER:
    ss << "OTHER -> 'Some source that isn't one of these'";
    break;
  default:
    ss << "NONE";
    break;
  }
  ss << std::endl;

  ss << "type: ";
  switch (type) {
  case GL_DEBUG_TYPE_ERROR:
    ss << "ERROR -> 'An error, typically from the API'";
    break;
  case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
    ss << "DEPRECATED_BEHAVIOR -> 'Some behavior marked deprecated has been used'";
    break;
  case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
    ss << "UNDEFINED_BEHAVIOR -> 'Something has invoked undefined behavior'";
    break;
  case GL_DEBUG_TYPE_PORTABILITY:
    ss << "PORTABILITY -> 'Some functionality the user relies upon is not portable'";
    break;
  case GL_DEBUG_TYPE_PERFORMANCE:
    ss << "PERFORMANCE -> 'Code has triggered possible performance issues'";
    break;
  case GL_DEBUG_TYPE_MARKER:
    ss << "MARKER -> 'Command stream annotation'";
    break;
  case GL_DEBUG_TYPE_PUSH_GROUP:
    ss << "PUSH_GROUP -> 'Group pushing'";
    break;
  case GL_DEBUG_TYPE_POP_GROUP:
    ss << "POP_GROUP -> 'Group popping'";
    break;
  case GL_DEBUG_TYPE_OTHER:
    ss << "OTHER -> 'Some type that isn't one of these'";
    break;
  default:
    ss << "NONE";
    break;
  }
  ss << std::endl;

  ss << "id: " << id << std::endl;
  
  ss << "severity: ";
  switch (severity){
  case GL_DEBUG_SEVERITY_HIGH:
    ss << "HIGH -> 'All OpenGL Errors , shader compilation/linking errors, or highly-dangerous undefined behavior'";
    break;
  case GL_DEBUG_SEVERITY_MEDIUM:
    ss << "MEDIUM -> 'Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality'";
    break;
  case GL_DEBUG_SEVERITY_LOW:
    ss << "LOW -> 'Redundant state change performance warning, or unimportant undefined behavior'";
    break;
  case GL_DEBUG_SEVERITY_NOTIFICATION:
    ss << "NOTIFICATION -> 'Anything that isn't an error or performance issue.'";
    break;
  default:
    ss << "NONE";
    break;
  }
  ss << std::endl;
  ss << "---------------------OpenGL DebugCallback End--------------" << std::endl;

  // 通知以外なら表示する
  if (severity != GL_DEBUG_SEVERITY_NOTIFICATION)
  {
    OutputDebugStringA(ss.str().c_str());
  }

  // エラーの深刻度がHIGHならアサートで止める
  if (severity == GL_DEBUG_SEVERITY_HIGH)
  {
    GFL_ASSERT(false);
  }
}

void WinOpenGLGL::SetTargetFPS(f64 fps)
{
  s_Gp->m_TargetFPS = fps;
}

//-----------------------------------------------------------------------------
/// @brief	
//-----------------------------------------------------------------------------
DisplayDeviceHandle WinOpenGLGL::CreateDisplayEx( IGLAllocator* allocator, HWND hWnmd, Format colorFormat, Format depthStencilFormat, MultiSample multiSample )
{
  s_Gp->m_hWnd = hWnmd;

  RECT rect;
  GetClientRect(hWnmd, &rect);

  u32 width = rect.right - rect.left;
  u32 height = rect.bottom - rect.top;

  GLMemory::SetInstanceAllocator( allocator );
  // OpenGL初期化
  if (!s_Gp->initOpenGL())
  {
    GFL_ASSERT(false);
  }

	DisplayDeviceHandle handle = s_Gp->createDisplay_( DisplayMode::UserSetting, width, height, false, colorFormat, depthStencilFormat, multiSample );
  GLMemory::ClearInstanceAllocator();

  return handle;
}

//! @brief ディスプレイデバイスを作成する(ウィンドウスタイル指定版)
//! @return ディスプレイのデバイスはライブラリで完全にコントロールします。よってハンドルのみを返します。
DisplayDeviceHandle WinOpenGLGL::CreateDisplayEx(
  IGLAllocator*     allocator,          //!< アロケーター
  u32								width,							//!< ディスプレイの幅
  u32								height,							//!< ディスプレイの高さ
  b32								isFullScreen,				//!< フルスクリーンか
  Format						colorFormat,		    //!< カラーバッファのピクセルフォーマット
  Format						depthStencilFormat, //!< 深度ステンシルバッファのピクセルフォーマット
  MultiSample				multiSample,				//!< マルチサンプルモード
  DWORD             windowStyle             //!< ウィンドウスタイル
  )
{
  DisplayDeviceHandle handle = s_Gp->CreateDisplay_( DisplayMode::UserSetting, width, height, isFullScreen, colorFormat, depthStencilFormat, multiSample, windowStyle );
  return handle;
}

//-----------------------------------------------------------------------------
/// @brief	リードファイル関数
//-----------------------------------------------------------------------------
char* WinOpenGLGL::ReadFile( const char* filename, s32* p_size, s32 align, gfx::IGLAllocator* pAllocator )
{
	FILE		*hFile;
	int			file_size;
	char		*read_buff;
	errno_t	error;

	error = fopen_s( &hFile, filename, "rb" );

	if ( hFile == NULL || error ){
		GFL_ASSERT(0);
		return NULL;
	}

	fseek( hFile, 0, SEEK_END );
	file_size = ftell( hFile );
	*p_size = file_size;
	fseek( hFile, 0, SEEK_SET );

	s32 buf_size = file_size + align;//必ずNULLが入るようにしたい。

	buf_size = buf_size + ((-buf_size) & (align-1));

  if ( pAllocator )
  {
    read_buff = reinterpret_cast<char*>( pAllocator->SystemMemoryMalloc( buf_size ) );
  }
  else
  {
	  read_buff = reinterpret_cast<char*>( GLMemory::Malloc(buf_size) );
  }

	memset( read_buff, 0, buf_size );
	fread_s( read_buff, buf_size, 1, file_size, hFile );
	fclose( hFile );

	return( read_buff );
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
WinOpenGLGL::WinOpenGLGL() : CommonGL(),
	m_hInst(NULL),
	m_hWnd(NULL),
  m_IsCtrMode(false),
	m_pCurrentShader(NULL),
	m_pCurrentIndexBuffer(NULL),
  m_TargetFPS(60.0),
  m_OverTime(0),
  m_VSyncBeginTime(0),
  m_VSyncFrameCount(0)
{
	for( int i = 0; i < MRT_MAX; ++i )
		m_ActgiveRenderTarget[ i ] = NULL;

	m_ActgiveDepthStencil = NULL;

	//  ウィンドウクラスを登録
  if( registerWindowClass( s_szRegName ) == false )
	{
      return;
  }

	for( u32 i = 0; i < TEXTURE_MAX; ++i )
		m_pCurrentTexture[i] = NULL;

  // ディスプレイウィンドウ初期化
  for (u32 i = 0; i < CtrDisplayNo::NumberOf; ++i)
  {
    m_pCtrSwapDisplayWindowList[i] = NULL;
  }

	s_Gp = this;
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
WinOpenGLGL::~WinOpenGLGL()
{
  if (s_Gp->m_pTotalTimerQuery != NULL)
  {
    delete s_Gp->m_pTotalTimerQuery;
    s_Gp->m_pTotalTimerQuery = NULL;
  }
	s_Gp = NULL;
}

//----------------------------------------------------------------------------
/**
 *	@brief  ウィンドウクラスを登録する
 */
//-----------------------------------------------------------------------------
inline bool WinOpenGLGL::registerWindowClass( const char* rcn )
{
	WNDCLASSEX  wc;
	
	wc.lpszClassName = rcn;
	wc.cbSize        = sizeof(WNDCLASSEX);
	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wc.lpfnWndProc   = WinOpenGLGL::MainWndProc;
	wc.hInstance     = s_hInstance;
	wc.hIcon         = NULL;
	wc.hIconSm       = NULL;
	wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wc.hbrBackground = (HBRUSH)GetStockObject( NULL_BRUSH );
	wc.lpszMenuName  = NULL;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	
	if( ::RegisterClassEx( &wc ) == 0 ){
		return false;
	}
	
	return true;
}

//----------------------------------------------------------------------------
/**
 *	@brief  ウィンドウを作成する
 */
//-----------------------------------------------------------------------------
inline HWND WinOpenGLGL::createWindow( HWND hParent, const char* rcn, b32 fullScreen, u32 width, u32 height, DWORD windowStyle )
{
  RECT rec;
  HWND hWnd = NULL;

  if( fullScreen )
	{
      static const DWORD kStyleEx = WS_EX_APPWINDOW;

      hWnd = CreateWindowEx(
          kStyleEx, rcn, "", windowStyle,
          0, 0, width, height,
          hParent, NULL, s_hInstance, NULL
      );
  }
  else{
      static const DWORD kStyleEx = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;

      ::SetRect( &rec, 0, 0, width, height );
      if( AdjustWindowRectEx( &rec, windowStyle, FALSE, kStyleEx ) == 0 ){
          return false;
      }

		hWnd = CreateWindowEx(
			kStyleEx, rcn, "", windowStyle,
			CW_USEDEFAULT, CW_USEDEFAULT ,
			rec.right - rec.left, rec.bottom - rec.top,
			hParent, NULL, s_hInstance, NULL
		);
  }

	// ウインドウ表示
	//if ( windowStyle & WS_VISIBLE )
	{
		ShowWindow(hWnd, SW_SHOWNORMAL);
		UpdateWindow(hWnd);
	}

  return hWnd;
}

DisplayDeviceHandle WinOpenGLGL::createDisplay_( DisplayMode displayMode, u32 width, u32 height, b32 isFullScreen, Format colorFormat, Format depthStencilFormat, MultiSample multiSample )
{
  (void)isFullScreen;
  (void)colorFormat;
  (void)depthStencilFormat;

  DisplayWindow* pDisplayWindow = new DisplayWindow( m_hWnd, m_hdc, m_RenderContext, displayMode );
  pDisplayWindow->Init();

  // まだマルチサンプル対応できていません
  GFL_ASSERT(multiSample == MultiSample::None);

	{
    // カラーバッファ
		{
			Surface::SurfaceDesc				desc;

			desc.pool = Pool::Default;
			desc.width = width;
			desc.height = height;
			desc.depth = 1;
			desc.multiSample = multiSample;
			desc.usage = Usage::RenderTarget | Usage::Tiled;
			desc.format = Format::A8R8G8B8;

			Surface						*pSurface = new WinOpenGLSurface( desc );
			pDisplayWindow->m_pRenderTarget = pSurface;
		}

    // デプスステンシルバッファ
		{
			Texture::TextureDesc				desc;

			desc.pool = Pool::Default;
			desc.width = width;
			desc.height = height;
			desc.depth = 1;
			desc.multiSample = multiSample;
			desc.usage = Usage::DepthStencil | Usage::Tiled | Usage::ZCull | Usage::RenderTarget;
			desc.format = Format::D24S8;
			desc.mipLevels = 1;

			pDisplayWindow->m_pDepthStencil = new WinOpenGLTexture( desc );
		}
	}

	return pDisplayWindow;
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
bool WinOpenGLGL::initOpenGL()
{
  // OpenGL初期化
  // ピクセルフォーマット初期化
  PIXELFORMATDESCRIPTOR pfd =
  {
    sizeof(PIXELFORMATDESCRIPTOR),
    1,
    PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, //Flags
    PFD_TYPE_RGBA, //The kind of framebuffer. RGBA or palette.
    32, //Colordepth of the framebuffer.
    0, 0, 0, 0, 0, 0,
    0,
    0,
    0,
    0, 0, 0, 0,
    24, //Number of bits for the depthbuffer
    8, //Number of bits for the stencilbuffer
    0, //Number of Aux buffers in the framebuffer.
    PFD_MAIN_PLANE,
    0,
    0, 0, 0
  };

  m_hdc = GetDC( m_hWnd );
  int		format = ChoosePixelFormat(m_hdc, &pfd);

  if (format == 0)
  {
    return false;
  }

  if ( !SetPixelFormat(m_hdc, format, &pfd) )
  {
    return false;
  }

  m_RenderContext = wglCreateContext(m_hdc);
  wglMakeCurrent(m_hdc, m_RenderContext);

  GLenum err = glewInit();
  GFL_ASSERT( err == GLEW_OK );

  // OpenGLのデバッグコールバック登録
  glDebugMessageCallback(GlDebugCallback, this);
  glEnable(GL_DEBUG_OUTPUT);
  glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);  // これが無いと非同期でコールバックを呼ばれてどこが原因なのか分かり難い

  // プログラムパイプライン作成
  glGenProgramPipelines(1, &m_ProgramPipeline);

  // タイマークエリ作成
  m_pTotalTimerQuery = this->CreateTimerQuery_();

  // 垂直同期無効
  PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress("wglSwapIntervalEXT");
  if (wglSwapIntervalEXT != NULL)
  {
    wglSwapIntervalEXT(0);
  }

  return true;
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
DisplayDeviceHandle WinOpenGLGL::CreateDisplay_( DisplayMode displayMode, u32 width, u32 height, b32 isFullScreen, Format colorFormat, Format depthStencilFormat, MultiSample multiSample, DWORD windowStyle )
{
  // 最初の一度だけメインウィンドウ作成
  if (m_hWnd == NULL)
  {
    m_IsCtrMode = (displayMode == DisplayMode::CTR_LEFT) || (displayMode == DisplayMode::CTR_RIGHT) || (displayMode == DisplayMode::CTR_DOWN);
    if (m_IsCtrMode)
    {
      // CTRエミュレーション用
      m_hWnd = createWindow( NULL, s_szRegName, false, sc_windowWidthUpDown, sc_windowHeightUpDown, windowStyle);
    }
    else
    {
      // 通常
      m_hWnd = createWindow( NULL, s_szRegName, isFullScreen, width, height, windowStyle );
    }

    // OpenGL初期化
    if (!initOpenGL())
    {
      GFL_ASSERT(false);
    }
  }

  // CTRと挙動を揃えるために幅と高さを固定にする
  if (m_IsCtrMode)
  {
    width = sc_frameBufferWidth;
    height = sc_frameBufferHeight;
  }

	return createDisplay_( displayMode, width, height, isFullScreen, colorFormat, depthStencilFormat, multiSample );
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
void WinOpenGLGL::DestroyDisplay_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
	if ( pDisplay == NULL )
		return;
	delete pDisplay;
}

//----------------------------------------------------------------------------
/**
 *	@brief  バックバッファを取得する
 */
//-----------------------------------------------------------------------------
Surface* WinOpenGLGL::GetBackBuffer_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
	if ( pDisplay == NULL )
		return NULL;

	return pDisplay->m_pRenderTarget;
}

//----------------------------------------------------------------------------
/**
 *	@brief  深度ステンシルバッファを取得する
 */
//-----------------------------------------------------------------------------
Surface* WinOpenGLGL::GetDepthStencilBuffer_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
	if ( pDisplay == NULL )
		return NULL;

	return const_cast<Surface*>( pDisplay->m_pDepthStencil->GetSurface() );
}

//----------------------------------------------------------------------------
/**
 *	@brief  深度ステンシルテクスチャを取得する
 */
//-----------------------------------------------------------------------------
Texture* WinOpenGLGL::GetDepthStencilTexture_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
	if ( pDisplay == NULL )
		return NULL;

	return pDisplay->m_pDepthStencil;
}

//----------------------------------------------------------------------------
/**
 *	@brief  サーフェイスを作成する
 */
//-----------------------------------------------------------------------------
Surface* WinOpenGLGL::CreateSurface_( const Surface::SurfaceDesc &rDesc )
{
	Surface									*pSurface = NULL;
	pSurface = new WinOpenGLSurface( rDesc );
	return pSurface;
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
void WinOpenGLGL::TransferDisplay_()
{
  // CTRモードのみ
  if (!m_IsCtrMode)
  {
    return;
  }

	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( m_pActiveDisplay );
  m_pCtrSwapDisplayWindowList[pDisplay->GetCtrDisplayNo()] = pDisplay;
}

//----------------------------------------------------------------------------
/**
 *	@brief  
 */
//-----------------------------------------------------------------------------
bool WinOpenGLGL::SwapDisplay_WaitGPUCommandDone_()
{
  if (m_IsCtrMode)
  {
    // CTRモード

    // デフォルトフレームバッファをバインド
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    // このフレームバッファ用にビューポートとシザーを設定
    glViewport(0, 0, sc_windowWidthUpDown, sc_windowHeightUpDown);
    glScissor(0, 0, sc_windowWidthUpDown, sc_windowHeightUpDown);

    // バッファクリア
    glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // 転送先のフレームバッファとしてバインド
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);

    // 上画面転送
    if (m_pCtrSwapDisplayWindowList[CtrDisplayNo::LEFT] != NULL)
    {
      DisplayWindow* pDisplay = m_pCtrSwapDisplayWindowList[CtrDisplayNo::LEFT];

      u32 width = sc_windowWidthUp;
      u32 height = sc_windowHeightUp;

      u32 offsetY = height;
      glBindFramebuffer( GL_READ_FRAMEBUFFER, pDisplay->m_FrameBufferID );
      glBlitFramebuffer( 0, 0, width, height, 0, offsetY, width, height + offsetY, GL_COLOR_BUFFER_BIT, GL_NEAREST );
    }

    // 下画面転送
    if (m_pCtrSwapDisplayWindowList[CtrDisplayNo::DOWN] != NULL)
    {
      DisplayWindow* pDisplay = m_pCtrSwapDisplayWindowList[CtrDisplayNo::DOWN];

      u32 width = sc_windowWidthDown;
      u32 height = sc_windowHeightDown;
      u32 offsetX = (sc_windowWidthUpDown - sc_windowWidthDown) / 2;
      glBindFramebuffer( GL_READ_FRAMEBUFFER, pDisplay->m_FrameBufferID );
      glBlitFramebuffer( 0, 0, width, height, offsetX, 0, width + offsetX, height, GL_COLOR_BUFFER_BIT, GL_NEAREST );
    }
  }
  else
  {
    GFL_ASSERT( m_pActiveDisplay );

    // 通常
    DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( m_pActiveDisplay );

    u32			width = pDisplay->m_pRenderTarget->GetSurfaceDesc().width;
    u32			height = pDisplay->m_pRenderTarget->GetSurfaceDesc().height;

    RECT rect;
    GetClientRect(m_hWnd, &rect);

    glViewport(0, 0, rect.right, rect.bottom);
    glScissor(0, 0, rect.right, rect.bottom);

    glBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
    glBindFramebuffer( GL_READ_FRAMEBUFFER, pDisplay->m_FrameBufferID );
    glBlitFramebuffer( 0, 0, width, height, 0, 0, rect.right, rect.bottom, GL_COLOR_BUFFER_BIT, GL_NEAREST );
  }

  this->EndTimerQuery_(m_pTotalTimerQuery);

  return true;
}
void WinOpenGLGL::SwapDisplay_SwapBuffers_()
{
	SwapBuffers(m_hdc);
}
void WinOpenGLGL::SwapDisplay_WaitVSync_()
{
  // 擬似VSync待ち
  s64 targetWaitTime = (s64)(1000000.0 / m_TargetFPS);
  s64 nextWaitTime = targetWaitTime * (m_VSyncFrameCount++) + m_VSyncBeginTime;
  s64 currentTime = system::Timer::PerformanceCounter::GetMicroSecond();

  if (currentTime < nextWaitTime)
  {
    // まず低精度タイマで大雑把なスリープ
    s32 sleepTime = (s32)((nextWaitTime - currentTime) / 1000);
    if (sleepTime > 2)
    {
      timeBeginPeriod(1);
      Sleep(sleepTime - 2);
      timeEndPeriod(1);
    }

    // 残りは高精度タイマでビジーループ
    currentTime = system::Timer::PerformanceCounter::GetMicroSecond();
    while (currentTime < nextWaitTime)
    {
      currentTime = system::Timer::PerformanceCounter::GetMicroSecond();
    }
  }
  else
  {
    // 遅れ過ぎていたら諦める
    s64 overTime = currentTime - nextWaitTime;
    if (overTime / targetWaitTime > 5)
    {
      // リセット
      m_VSyncBeginTime = system::Timer::PerformanceCounter::GetMicroSecond();
      m_VSyncFrameCount = 0;
    }
  }

  // ディスプレイウィンドウ初期化
  for (u32 i = 0; i < CtrDisplayNo::NumberOf; ++i)
  {
    m_pCtrSwapDisplayWindowList[i] = NULL;
  }
}
void WinOpenGLGL::SwapDisplay_RunGPUCommand_()
{
  this->BeginTimerQuery_(m_pTotalTimerQuery);
}

//----------------------------------------------------------------------------
/**
 *   @brief レンダリングターゲットを切り替える
//! @par index でＭＲＴカラーバッファのインデクスを指定
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::SetRenderTarget_(u32 index, const Surface* const pSurface)
{
	if ( index >= MRT_MAX )
		return false;

	const WinOpenGLSurface*			pConstWinOpenGLSurface = down_cast<const WinOpenGLSurface*>( pSurface );//clearで使うので記憶したいので、苦しいがconst外し
	WinOpenGLSurface*						pWinOpenGLSurface = (WinOpenGLSurface*)pConstWinOpenGLSurface;

	if ( pWinOpenGLSurface )
		pWinOpenGLSurface->SetSetTargetSlotNo( index );

	m_ActgiveRenderTarget[index] = pWinOpenGLSurface;

	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 現在のレンダリングターゲットを取得する
*/
//-----------------------------------------------------------------------------
const Surface* WinOpenGLGL::GetRenderTarget_(u32 index)
{
	if ( index >= MRT_MAX )
		return NULL;
	return m_ActgiveRenderTarget[index];
}

//----------------------------------------------------------------------------
/**
 *   @brief 深度ステンシルを切り替える
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::SetDepthStencil_(const Surface* const pSurface)
{
  if (pSurface == NULL)
  {// NULLが設定されていても問題ないのでtrueを返す
    m_ActgiveDepthStencil = NULL;
    return true;
  }

	m_ActgiveDepthStencil = down_cast<const WinOpenGLSurface*>( pSurface );
	GFL_ASSERT( m_ActgiveDepthStencil );    // これはキャストがしくじった場合のassert.
	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 現在の深度ステンシルを取得する
*/
//-----------------------------------------------------------------------------
const Surface* WinOpenGLGL::GetDepthStencil_()
{
	return m_ActgiveDepthStencil;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::BeginTimerQuery_( const TimerQuery* pTimerQuery )
{
  // const外します
  TimerQuery* pTmp = const_cast<TimerQuery*>(pTimerQuery);
  WinOpenGLTimerQuery* pWinTimerQuery = static_cast<WinOpenGLTimerQuery*>(pTmp);

  // 計測開始
  pWinTimerQuery->Begin();
	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::EndTimerQuery_( const TimerQuery* pTimerQuery)
{
  // const外します
  TimerQuery* pTmp = const_cast<TimerQuery*>(pTimerQuery);
  WinOpenGLTimerQuery* pWinTimerQuery = static_cast<WinOpenGLTimerQuery*>(pTmp);

  // 計測終了
  pWinTimerQuery->End();
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::BeginOcclusionQuery_( const OcclusionQuery* pOcclusionQuery)
{
  (void)pOcclusionQuery;

	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::EndOcclusionQuery_( const OcclusionQuery* pOcclusionQuery)
{
  (void)pOcclusionQuery;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::BeginConditionalRender_( const OcclusionQuery *pQuery )
{
  (void)pQuery;

  return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::EndConditionalRender_( const OcclusionQuery *pQuery )
{
  (void)pQuery;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::BlitSurfaceToTexture_(const Surface* pSurfaceSrc,const Texture* pTextureDst)
{
	// コピー元のプロパティを取得
	const WinOpenGLSurface* pWinOpenGLSurfaceSrc = down_cast<const WinOpenGLSurface*>( pSurfaceSrc );
	u32	srcWidth  = pWinOpenGLSurfaceSrc->GetSurfaceDesc().width;
    u32	srcHeight = pWinOpenGLSurfaceSrc->GetSurfaceDesc().height;

	// サーフェス間のコピー
	const Surface* pSurface = GetRenderTarget_(0);
	SetTexture_(0,pTextureDst);
	SetRenderTarget_(0,pSurfaceSrc);
	glCopyTexSubImage2D( GL_TEXTURE_2D ,0,0,0,0,0,srcWidth,srcHeight);
	SetRenderTarget_(0,pSurface);

	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
b32 WinOpenGLGL::BeginScene_()
{
	const DisplayWindow* pDisplay = reinterpret_cast< DisplayWindow* >( m_pActiveDisplay );
	if ( pDisplay == false )		return false;

	wglMakeCurrent( pDisplay->m_hdc, pDisplay->m_RenderContext );

	GLenum bufs[] = {
		GL_COLOR_ATTACHMENT0,
		GL_COLOR_ATTACHMENT1,
		GL_COLOR_ATTACHMENT2,
		GL_COLOR_ATTACHMENT3,
		GL_COLOR_ATTACHMENT4,
		GL_COLOR_ATTACHMENT5,
		GL_COLOR_ATTACHMENT6,
		GL_COLOR_ATTACHMENT7,
	};

	s32			numMRT = 0;

	for( s32 i = 0; i < MRT_MAX; ++i )
	{
		if ( m_ActgiveRenderTarget[i] )
		{
			GLuint				handle = m_ActgiveRenderTarget[i]->GetHandle();

			if ( m_ActgiveRenderTarget[i]->IsTexture() )
			{
        glNamedFramebufferTexture2DEXT( pDisplay->m_FrameBufferID, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, handle, 0);
			}
			else
			{
				glNamedFramebufferRenderbufferEXT( pDisplay->m_FrameBufferID, GL_COLOR_ATTACHMENT0 + i, GL_RENDERBUFFER, handle );
			}

			++numMRT;
		}
		else
		{
			glNamedFramebufferRenderbufferEXT( pDisplay->m_FrameBufferID, GL_COLOR_ATTACHMENT0 + i, GL_RENDERBUFFER, NULL );
		}
	}

  if (m_ActgiveDepthStencil)
  {
  	glNamedFramebufferTexture2DEXT( pDisplay->m_FrameBufferID, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, m_ActgiveDepthStencil->GetHandle(), 0 );
  }
  else
  {
    glNamedFramebufferTexture2DEXT( pDisplay->m_FrameBufferID, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, NULL, 0 );
  }

  // フレームバッファの状態を確認
  GLenum status = glCheckNamedFramebufferStatusEXT( pDisplay->m_FrameBufferID, GL_FRAMEBUFFER );
  if (status != GL_FRAMEBUFFER_COMPLETE)
  {
    // エラーで分岐
    const char* errorMessage = NULL;
    switch (status)
    {
    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: // アタッチメントされていない
      errorMessage = "Not all framebuffer attachment points are framebuffer attachment complete.";
      break;

    case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT: // 各アタッチメントの幅と高さが合わない
      errorMessage = "Not all attached images have the same width and height.";
      break;

    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: // アタッチメントされたハンドルが無効
      errorMessage = "No images are attached to the framebuffer.";
      break;

    case GL_FRAMEBUFFER_UNSUPPORTED: // 未対応のフォーマット
      errorMessage = "The combination of internal formats of the attached images violates an implementation-dependent set of restrictions.";
      break;
    }

    // フレームバッファの設定が足りない、もしくは間違いがあるまま描画に入ろうとしている
    OutputDebugStringA(errorMessage);
    GFL_ASSERT(0);
  }
	glBindFramebuffer( GL_FRAMEBUFFER, pDisplay->m_FrameBufferID );
	glDrawBuffers( numMRT, bufs );

	return true;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::EndScene_()
{
	//Windows DirectXはリングバッファ形式。キックコマンドなどはない。
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::Finish_()
{
	glFlush();
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::ClearRenderTarget_( u32 index, const Color &rClearColor )
{
	const WinOpenGLSurface			*pWinOpenGLSurface = m_ActgiveRenderTarget[index];

	glColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
	glClearBufferfv( GL_COLOR, pWinOpenGLSurface->GetSetTargetSlotNo(), &rClearColor.x );
}

//----------------------------------------------------------------------------
/**
 *   @brief 深度ステンシルをクリアする
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::ClearDepthStencil_( f32 depth, u8 stencil )
{
	glDepthMask( GL_TRUE );
	glStencilMask( GL_TRUE );

	glClearDepth( depth );
	glClearStencil( stencil );
	glClear( GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );
}

//! @brief レンダリングターゲットと深度ステンシルをクリアする
void WinOpenGLGL::ClearRenderTargetDepthStencil_( u32 index, const Color &rClearColor, f32 depth, u8 stencil )
{
	ClearRenderTarget_(index, rClearColor);
	ClearDepthStencil_(depth, stencil);
}

//----------------------------------------------------------------------------
/**
 *   @brief ビューポートを設定する
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetViewport_(const u32 xp, const u32 yp, const u32 width, const u32 height)
{
	glViewport( xp, yp, width, height );
}

//----------------------------------------------------------------------------
/**
 *   @brief シザーを設定する
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetScissor_(const u32 xp, const u32 yp, const u32 width, const u32 height)
{
  glEnable( GL_SCISSOR_TEST );
  glScissor( xp, yp, width, height );
}

//----------------------------------------------------------------------------
/**
//! @brief 頂点シェーダーを切り替える
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetVertexShader_( const Shader* pShader )
{
	m_pCurrentShader = (WinOpenGLVertexShader*)pShader;
  u32 vsProgram = 0;

  if (m_pCurrentShader != NULL)
  {
    m_pCurrentShader->Bind();
    vsProgram = m_pCurrentShader->GetHandle();
  }

  glUseProgramStages(m_ProgramPipeline, GL_VERTEX_SHADER_BIT, vsProgram);

  // とりあえずここでプログラムパイプラインもバインド
  glUseProgram(0);
  glBindProgramPipeline(m_ProgramPipeline);
}

//----------------------------------------------------------------------------
/**
//! @brief ジオメトリシェーダーを切り替える
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetGeometryShader_( const Shader* pShader )
{
	const WinOpenGLGeometryShader* pGLShader = reinterpret_cast<const WinOpenGLGeometryShader*>( pShader );
  u32 gsProgram = 0;

  if (pGLShader != NULL)
  {
    gsProgram = pGLShader->GetHandle();
  }

  glUseProgramStages(m_ProgramPipeline, GL_GEOMETRY_SHADER_BIT, gsProgram);

  // とりあえずここでプログラムパイプラインもバインド
  glUseProgram(0);
  glBindProgramPipeline(m_ProgramPipeline);
}

//----------------------------------------------------------------------------
/**
//! @brief ピクセルシェーダーを切り替える
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetPixelShader_( const Shader* pShader )
{
	const WinOpenGLPixelShader* pGLShader = reinterpret_cast<const WinOpenGLPixelShader*>( pShader );
  u32 fsProgram = 0;

  if (pGLShader != NULL)
  {
    fsProgram = pGLShader->GetHandle();
  }

  glUseProgramStages(m_ProgramPipeline, GL_FRAGMENT_SHADER_BIT, fsProgram);

  // とりあえずここでプログラムパイプラインもバインド
  glUseProgram(0);
  glBindProgramPipeline(m_ProgramPipeline);
}

//----------------------------------------------------------------------------
/**
 *   @brief 頂点シェーダ定数設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetVertexShaderConstant_( u32 registerNo, ConstantBuffer *pBuffer )
{
	const WinOpenGLConstantBuffer* pGLBuffer = reinterpret_cast<const WinOpenGLConstantBuffer*>( pBuffer );
	glBindBufferBase( GL_UNIFORM_BUFFER, registerNo, pGLBuffer->GetHandle() );
}

//----------------------------------------------------------------------------
/**
 *   @brief ジオメトリシェーダ定数設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetGeometryShaderConstant_( u32 registerNo,	ConstantBuffer *pBuffer	)
{
	const WinOpenGLConstantBuffer* pGLBuffer = reinterpret_cast<const WinOpenGLConstantBuffer*>( pBuffer );
	glBindBufferBase( GL_UNIFORM_BUFFER, registerNo, pGLBuffer->GetHandle() );
}

//----------------------------------------------------------------------------
/**
 *   @brief ピクセルシェーダ定数設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetPixelShaderConstant_( u32 registerNo,	ConstantBuffer *pBuffer	)
{
	const WinOpenGLConstantBuffer* pGLBuffer = reinterpret_cast<const WinOpenGLConstantBuffer*>( pBuffer );
	glBindBufferBase( GL_UNIFORM_BUFFER, registerNo, pGLBuffer->GetHandle() );
}

//----------------------------------------------------------------------------
/**
 *   @brief インデクスバッファを設定します
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetIndices_(const IndexBuffer* pIndices)
{
	m_pCurrentIndexBuffer = reinterpret_cast<const WinOpenGLIndexBuffer*>( pIndices );
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_pCurrentIndexBuffer->GetHandle() );
}

//----------------------------------------------------------------------------
/**
 *   @brief 頂点バッファをストリームに設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetStreamSource_( const u32 index, const VertexBuffer* pVertexBuffer, const s32 offset, const s32 stride )
{
  (void)offset;
  (void)stride;

	const WinOpenGLVertexBuffer			*pGLVertexBuffer = reinterpret_cast<const WinOpenGLVertexBuffer*>( pVertexBuffer );
	m_pCurrentShader->BindVertyexAttribute( index, pGLVertexBuffer->GetHandle() );
}

//----------------------------------------------------------------------------
/**
 *   @brief 頂点ストリームにセットされた頂点を使って描画
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::DrawPrimitive_( PrimitiveType primitive, u32 start, u32 count	)
{
	glDrawArrays(s_openglPrimitiveType[ primitive ], start, count );
}

//----------------------------------------------------------------------------
/**
 *   @brief 頂点ストリームにセットされた頂点とインデックスバッファを使って描画
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::DrawIndexedPrimitive_( PrimitiveType primitive, u32	start, u32	count )
{
  (void)start;

	GFL_ASSERT( m_pCurrentIndexBuffer );
	IndexType			type = m_pCurrentIndexBuffer->GetIndexType();

	glDrawElements( s_openglPrimitiveType[ primitive ], count, s_openglIndexType[type], NULL );
}

//----------------------------------------------------------------------------
/**
 *   @brief ブレンドステートの設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetBlendState_( BlendStateObject *pState )
{
	WinOpenGLBlendStateObject				*pWinOpenGLBlendStateObject = down_cast<WinOpenGLBlendStateObject*>( pState );
	GFL_ASSERT( pWinOpenGLBlendStateObject );

	pWinOpenGLBlendStateObject->Bind( m_ActgiveRenderTarget, MRT_MAX );
}

//----------------------------------------------------------------------------
/**
 *   @brief ラスタライザステートの設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetRasterizerState_( RasterizerStateObject *pState )
{
	WinOpenGLRasterizerStateObject				*pWinOpenGLRasterizerStateObject = down_cast<WinOpenGLRasterizerStateObject*>( pState );
	GFL_ASSERT( pWinOpenGLRasterizerStateObject );

	pWinOpenGLRasterizerStateObject->Bind();
}

//----------------------------------------------------------------------------
/**
 *   @brief 深度ステンシルステートの設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetDepthStencilState_( DepthStencilStateObject *pState )
{
	WinOpenGLDepthStencilStateObject				*pWinOpenGLDepthStencilStateObject = down_cast<WinOpenGLDepthStencilStateObject*>( pState );
	GFL_ASSERT( pWinOpenGLDepthStencilStateObject );
	pWinOpenGLDepthStencilStateObject->Bind();
}

//----------------------------------------------------------------------------
/**
 *   @brief サンプラステートの設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetSamplerState_( u32 texNo, const SamplerStateObject *pState )
{
	const WinOpenGLSamplerStateObject	*pConstWinOpenGLSamplerStateObject = down_cast<const WinOpenGLSamplerStateObject*>( pState );
	GFL_ASSERT( pConstWinOpenGLSamplerStateObject );
	pConstWinOpenGLSamplerStateObject->Bind( texNo, m_pCurrentTexture[texNo] );
}

//----------------------------------------------------------------------------
/**
 *   @brief テクスチャの設定
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::SetTexture_( u32 texNo, const Texture *pTexture )
{
	m_pCurrentTexture[texNo] = reinterpret_cast<const WinOpenGLTexture*>( pTexture );

	glActiveTexture( GL_TEXTURE0 + texNo );

	if ( m_pCurrentTexture[texNo] )
	{
		glBindTexture( GL_TEXTURE_2D, m_pCurrentTexture[texNo]->GetHandle() );

		if ( pTexture->GetTextureDesc().format == Format::D24S8 )
		{
			glTexParameteri( GL_TEXTURE_2D, GL_DEPTH_STENCIL_TEXTURE_MODE, GL_STENCIL_INDEX );
		}
	}
	else
	{
		glBindTexture( GL_TEXTURE_2D, 0 );//リセット
	}

}

//----------------------------------------------------------------------------
/**
 *   @brief ファイルから頂点シェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateVertexShaderFromFile(const char* path, const char* entry, const VertexElement* pVertexElements, const char** args, FileFormat format)
{
  (void)entry;
  (void)args;
  (void)format;

	Shader		*pShader;

	{
		s32			size;
		char		*read_buff;

		read_buff = ReadFile( path, &size );
		pShader = s_Gp->CreateVertexShaderFromMemory_( read_buff, size, pVertexElements);

		GLMemory::Free( read_buff );
	}


	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータから頂点シェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateVertexShaderFromMemory(const void* code, u32 size, const VertexElement* pVertexElements)
{
  return s_Gp->CreateVertexShaderFromMemory_( code, size, pVertexElements);
}

//----------------------------------------------------------------------------
/**
 *   @brief ソースコードから頂点シェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateVertexShaderFromSource_(const char* code, const char* entry, const VertexElement* pVertexElements, const char** args)
{
  (void)entry;
  (void)args;

	Shader			*pShader = NULL;
	pShader = new WinOpenGLVertexShader( code, strlen(code), pVertexElements );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータから頂点シェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateVertexShaderFromMemory_(const void* code, u32 size, const VertexElement* pVertexElements)
{
	Shader					*pShader = NULL;
	pShader = new WinOpenGLVertexShader( code, size, pVertexElements );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief ファイルからジオメトリシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateGeometryShaderFromFile(const char* path, const char* entry, const char** args, FileFormat format)
{
  (void)entry;
  (void)args;
  (void)format;

	Shader		*pShader = NULL;

	{
		s32			size;
		char		*read_buff;

		read_buff = ReadFile( path, &size );
		pShader = s_Gp->CreateGeometryShaderFromMemory_( read_buff, size );

		GLMemory::Free( read_buff );
	}

	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータからジオメトリシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateGeometryShaderFromMemory(const void* code, u32 size)
{
  return s_Gp->CreateGeometryShaderFromMemory_( code, size );
}

//----------------------------------------------------------------------------
/**
 *   @brief ソースコードからジオメトリシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateGeometryShaderFromSource_(const char* code, const char* entry, const char** args)
{
  (void)entry;
  (void)args;

	Shader				*pShader = NULL;
	pShader = new WinOpenGLGeometryShader( code, strlen(code) );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータからジオメトリシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreateGeometryShaderFromMemory_(const void* code, u32 size)
{
	Shader							*pShader = NULL;
	pShader = new WinOpenGLGeometryShader( code, size );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief ファイルからピクセルシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreatePixelShaderFromFile(const char* path, const char* entry, const char** args, FileFormat format)
{
  (void)entry;
  (void)args;
  (void)format;

	Shader		*pShader;

	{
		s32			size;
		char		*read_buff;

		read_buff = ReadFile( path, &size );
		pShader = s_Gp->CreatePixelShaderFromMemory_( read_buff, size );

		GLMemory::Free( read_buff );
	}

	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータからピクセルシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreatePixelShaderFromMemory(const void* code, u32 size)
{
  return s_Gp->CreatePixelShaderFromMemory_( code, size );
}

//----------------------------------------------------------------------------
/**
 *   @brief ソースコードからピクセルシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreatePixelShaderFromSource_(const char* code, const char* entry, const char** args)
{
  (void)entry;
  (void)args;

	Shader				*pShader = NULL;
	pShader = new WinOpenGLPixelShader( code, strlen(code) );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータからピクセルシェーダーを作成
*/
//-----------------------------------------------------------------------------
Shader* WinOpenGLGL::CreatePixelShaderFromMemory_(const void* code, u32 size)
{
	Shader							*pShader = NULL;
	pShader = new WinOpenGLPixelShader( code, size );
	return pShader;
}

//----------------------------------------------------------------------------
/**
 *			@brief 定数バッファを作成
 */
//-----------------------------------------------------------------------------
ConstantBuffer* WinOpenGLGL::CreateConstantBuffer_( const ConstantBufferElement* pConstantBufferElements, u32 usage, Pool pool, const void* buffer )
{
	ConstantBuffer							*pConstantBuffer = NULL;
	pConstantBuffer = new WinOpenGLConstantBuffer( pConstantBufferElements, usage, pool, buffer );
	return pConstantBuffer;
}

//----------------------------------------------------------------------------
/**
 *   @brief バイナリデータから頂点シェーダーを作成
*/
//-----------------------------------------------------------------------------
VertexBuffer* WinOpenGLGL::CreateVertexBuffer_( u32 size, u32 vertex_num, u32 usage, Pool pool, const void* buffer )
{
	VertexBuffer							*pVertexBuffer = NULL;
	pVertexBuffer = new WinOpenGLVertexBuffer( size, vertex_num, usage, pool, buffer );
	return pVertexBuffer;
}

//! @brief インデックスバッファを作成
IndexBuffer* WinOpenGLGL::CreateIndexBuffer_( u32 size, u32 usage, Pool pool, IndexType type, const void* buffer )
{
	IndexBuffer							*pIndexBuffer = NULL;
	pIndexBuffer = new WinOpenGLIndexBuffer( size, usage, pool, type, buffer );
	return pIndexBuffer;
}

//----------------------------------------------------------------------------
/**
 *   @brief ブレンドステートオブジェクトを作成
*/
//-----------------------------------------------------------------------------
BlendStateObject* WinOpenGLGL::CreateBlendStateObject_()
{
	BlendStateObject							*pStateObj = NULL;
	pStateObj = new WinOpenGLBlendStateObject();
	return pStateObj;
}

//----------------------------------------------------------------------------
/**
 *   @brief ラスタライザステートオブジェクトを作成
*/
//-----------------------------------------------------------------------------
RasterizerStateObject* WinOpenGLGL::CreateRasterizerStateObject_()
{
	RasterizerStateObject							*pStateObj = NULL;
	pStateObj = new WinOpenGLRasterizerStateObject();
	return pStateObj;
}

//----------------------------------------------------------------------------
/**
 *   @brief 深度ステンシルステートオブジェクトを作成
*/
//-----------------------------------------------------------------------------
DepthStencilStateObject* WinOpenGLGL::CreateDepthStencilStateObject_()
{
	DepthStencilStateObject							*pStateObj = NULL;
	pStateObj = new WinOpenGLDepthStencilStateObject();
	return pStateObj;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
TimerQuery* WinOpenGLGL::CreateTimerQuery_()
{
  WinOpenGLTimerQuery* pTimerQuery = new WinOpenGLTimerQuery();
  return pTimerQuery;
}

//----------------------------------------------------------------------------
/**
 *   @brief 
*/
//-----------------------------------------------------------------------------
OcclusionQuery* WinOpenGLGL::CreateOcclusionQuery_()
{
  // 対応しない
  return NULL;
}

//----------------------------------------------------------------------------
/**
 *   @brief ディスプレイリストの作成
*/
//-----------------------------------------------------------------------------
DisplayList* WinOpenGLGL::CreateDisplayList_()
{
  WinOpenGLDisplayList* pDisplayList = new WinOpenGLDisplayList();
  return pDisplayList;
}

//----------------------------------------------------------------------------
/**
 *   @brief ディスプレイリストの呼び出し
*/
//-----------------------------------------------------------------------------
void WinOpenGLGL::CallDisplayList_(DisplayList* pDisplayList)
{
  WinOpenGLDisplayList* pWinDisplayList = static_cast<WinOpenGLDisplayList*>(pDisplayList);
  pWinDisplayList->Call();
}

//----------------------------------------------------------------------------
/**
 *   @brief サンプラステートオブジェクトを作成
*/
//-----------------------------------------------------------------------------
SamplerStateObject* WinOpenGLGL::CreateSamplerStateObject_()
{
	SamplerStateObject							*pStateObj = NULL;
	pStateObj = new WinOpenGLSamplerStateObject();
	return pStateObj;
}

//----------------------------------------------------------------------------
/**
 *   @brief ２Ｄテクスチャを作成する
//! @param usage オプション
//! @param mipLevels ミップマップレベル数指定( 1 - 13 )
*/
//-----------------------------------------------------------------------------
Texture* WinOpenGLGL::CreateTexture_(u32 width, u32 height, u32 mipLevels, u32 usage, Format format, Pool pool)
{
	Texture::TextureDesc				desc;

	desc.type = TextureType::Image;
	desc.usage = usage;
	desc.pool = pool;
	desc.width = width;
	desc.height = height;
	desc.depth = 1;
	desc.mipLevels = mipLevels;
	desc.format = format;
	desc.multiSample = MultiSample::None;

	Texture											*pTexture = NULL;
	pTexture = new WinOpenGLTexture( desc );
	return pTexture;
}

//----------------------------------------------------------------------------
/**
 *   @brief イメージデータから２Ｄテクスチャを作成する
*/
//-----------------------------------------------------------------------------
Texture* WinOpenGLGL::CreateTextureFromImage_( const ImageData &rImage, Pool pool)
{
	Texture::TextureDesc				desc;

	desc.type = TextureType::Image;

	if ( rImage.IsCubemap() ) 
	{
		desc.type = TextureType::Cube;
		desc.mipLevels = rImage.GetDepth();
		desc.depth = 1;
	}
	else if ( rImage.IsVolume() ) 
	{
		desc.type = TextureType::Volume;
		desc.mipLevels = 1;
		desc.depth = rImage.GetDepth();
	}
	else
	{
		desc.type = TextureType::Image;
		desc.mipLevels = rImage.GetDepth();
		desc.depth = 1;
	}

	desc.usage = Usage::WriteOnly;
	desc.pool = pool;
	desc.width = rImage.GetWidth();
	desc.height = rImage.GetHeight();
	desc.format = rImage.GetFormat();
	desc.multiSample = MultiSample::None;

	Texture											*pTexture = NULL;
	pTexture = new WinOpenGLTexture( desc );

	//s32 surfaceLevel = 0;
	for( u32 surfaceLevel = 0; surfaceLevel < rImage.GetDepth(); ++surfaceLevel )
	{
		pTexture->Update( rImage.GetImage(surfaceLevel), surfaceLevel );
	}

	return pTexture;
}

//! @brief サーフェースから２Ｄテクスチャを作成する
Texture* WinOpenGLGL::CreateTextureFromSurface_( const Surface* pSurface )
{
  (void)pSurface;

  // 対応できない
  // RenderBufferを使わずに全てTextureにする？
  return NULL;
}

// 画面サイズ取得：幅
u32 WinOpenGLGL::GetDisplayWidth_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
  if (pDisplay == NULL)
  {
    return 0;
  }

  if (m_IsCtrMode)
  {
    return (pDisplay->GetCtrDisplayNo() == CtrDisplayNo::DOWN)
      ? sc_windowWidthDown
      : sc_windowWidthUp;
  }

  return pDisplay->m_pRenderTarget->GetSurfaceDesc().width;
}

// 画面サイズ取得：高さ
u32 WinOpenGLGL::GetDisplayHeight_( DisplayDeviceHandle hDisplay )
{
	DisplayWindow* const pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );
  if (pDisplay == NULL)
  {
    return 0;
  }

  if (m_IsCtrMode)
  {
    return sc_windowHeightUp;
  }

  return pDisplay->m_pRenderTarget->GetSurfaceDesc().height;
}

void WinOpenGLGL::AddTransferColorBufferCommand(void* pDestAddr)
{
  const DisplayDeviceHandle hDisplay = s_Gp->GetActiveDisplay_();
  const DisplayWindow* pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );

  u32 frameBufferWidth = 512;
  u32 frameBufferHeight = 256;

  glBindFramebuffer( GL_READ_FRAMEBUFFER, pDisplay->m_FrameBufferID );

  glReadPixels(0, 0, frameBufferWidth, frameBufferHeight, GL_RGBA, GL_UNSIGNED_BYTE, pDestAddr);
}

void WinOpenGLGL::AddTransferLinearColorBufferCommand(void* pDestAddr, b32 includeAlpha)
{
  const DisplayDeviceHandle hDisplay = s_Gp->GetActiveDisplay_();
  const DisplayWindow* pDisplay = reinterpret_cast< DisplayWindow* >( hDisplay );

  u32 frameBufferWidth = 512;
  u32 frameBufferHeight = 256;

  glBindFramebuffer( GL_READ_FRAMEBUFFER, pDisplay->m_FrameBufferID );

  glReadPixels(0, 0, frameBufferWidth, frameBufferHeight, (includeAlpha? GL_BGRA : GL_BGR), GL_UNSIGNED_BYTE, pDestAddr);
}

void WinOpenGLGL::AddReadColorBufferToTextureCommand(Texture* pTexture)
{
  void* buf = pTexture->Lock();
  AddTransferColorBufferCommand(buf);
  pTexture->UnLock();
}

}}}