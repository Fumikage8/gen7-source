#pragma once
//=================================================================================================
/**
 *  @file  movemodel.h
 *  @brief
 *  @date  2014.02.24
 *  @author tamada@gamefreak.co.jp
 */
//=================================================================================================
#include <heap/include/gfl2_Heap.h>
#include <Animation/include/gfl2_AnimationController.h>
#include <Animation/include/gfl2_JointController.h>
#include "FieldActionCmdBase.h"
#include "chara_define.h"
#include "movemodel_define.h"
#include "movecode.h"
#include "../include/SimpleCollisionCallbackable.h"

class FieldTransform;

namespace gfl2
{ 
  namespace collision 
  { 
    class CollisionModel;
  }
  namespace renderingengine { namespace scenegraph 
  {
    namespace resource { class ResourceNode;      }
    namespace instance { class ModelInstanceNode; }
  }}
}

namespace fld{ namespace mmodel {

class MoveModelManager;

class MoveModel
{
public:

  //! LOD
  enum LOD
  {
    LOD_LOW,
    LOD_MIDDLE,
    LOD_HIGH,
    LOD_NONE,
    LOD_MAX,
  };

  //-----------------------------------------------------------------------------
  /**
  *  @brief  コンストラクタ
  */
  //-----------------------------------------------------------------------------
  MoveModel( gfl2::heap::HeapBase * p_heap );

  //-----------------------------------------------------------------------------
  /**
  *  @brief  デストラクタ
  */
  //-----------------------------------------------------------------------------
  ~MoveModel();

  //----------------------------------------------------------------------------
  /**
  *  @brief  初期化
  *
  *  @param  p_header  リクエスト
  *  @return 動作コード
  */
  //-----------------------------------------------------------------------------
  bool Setup( const MoveModelHeader * p_header );

  //----------------------------------------------------------------------------
  /**
  *  @brief  解放
  */
  //-----------------------------------------------------------------------------
  void Clear( void );

  //----------------------------------------------------------------------------
  /**
  *  @brief  ムーブモデルマネージャーを登録
  *
  *  @param  p_manager  登録する
  *  @return 動作コード
  */
  //-----------------------------------------------------------------------------
  bool activate( MoveModelManager * p_manager );

  //----------------------------------------------------------------------------
  /**
  *  @brief  シーングラフに自身のモデルインスタンスノードが登録されているかどうか
  *
  *  @return 登録されているかどうか
  */
  //-----------------------------------------------------------------------------
  b32 isRegistSceneGraph( void ){ return m_isRegistSceneGraph; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  シーングラフに自身のモデルインスタンスノードを登録する(トラバース有効)
  */
  //-----------------------------------------------------------------------------
  void addSceneGraph( void );

  //----------------------------------------------------------------------------
  /**
  *  @brief  シーングラフから自身のモデルインスタンスノードを登録解除する(トラバース無効)
  */
  //-----------------------------------------------------------------------------
  void removeSceneGraph( void );

  //----------------------------------------------------------------------------
  /**
  * @brief 親モデルの設定
  *
  * @param pParent 親になるモデル
  * @param jointIndex 接続するジョイント番号：-1でモデル自体に接続
  */
  //----------------------------------------------------------------------------
  void SetParent(MoveModel* pParent, s32 jointIndex = -1);

  //----------------------------------------------------------------------------
  /**
  * @brief 子モデルの切り離し
  */
  //----------------------------------------------------------------------------
  void RemoveChild(void);

  //----------------------------------------------------------------------------
  /**
  * @brief 親モデルの取得
  *
  * @return 親モデルを返す
  */
  //----------------------------------------------------------------------------
  MoveModel* GetParent() const;

  //----------------------------------------------------------------------------
  /**
  * @brief 親モデルの接続先のジョイント番号取得
  *
  * @return 親モデルの接続先のジョイント番号を返す、-1でモデル自体に接続
  */
  //----------------------------------------------------------------------------
  s32 GetParentJointIndex() const;

  //----------------------------------------------------------------------------
  /**
  *  @brief  更新
  */
  //-----------------------------------------------------------------------------
  void update( void );

  //----------------------------------------------------------------------------
  /**
  *  @brief  存在しているかどうか
  *
  *  @return trueなら存在している、falseなら存在していない
  */
  //-----------------------------------------------------------------------------
  bool GetExists( void ) const { return m_exists; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  モデルヘッダーを取得
  *
  *  @return モデルヘッダー
  */
  //-----------------------------------------------------------------------------
  MoveModelHeader  GetHeader( void ) const { return m_Header; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  衝突されるコリジョンモデルを取得
  *
  *  @return コリジョンモデル
  */
  //-----------------------------------------------------------------------------
  gfl2::collision::CollisionModel* GetStaticCollision( void ) const { return m_pStaticCollisionModel; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  座標・姿勢・スケールを取得
  *
  *  @return 座標・姿勢・スケール
  */
  //-----------------------------------------------------------------------------
  FieldTransform*  GetTransform( void ) const { return m_transform; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  再生中のアニメーションIDを取得
  *
  *  @return アニメーションID
  */
  //-----------------------------------------------------------------------------
  int  GetAnimeID( void ) const { return m_animeNo; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  アニメーションを変更
  *
  *  @param  id           アニメーションID
  *  @param  loopFlag     ループするかどうか
  *  @param  interpFrame  補完フレーム
  *  @param  stepFrame    再生するフレームスピード
  *  @return 成否
  */
  //-----------------------------------------------------------------------------
  b32  ChangeAnimation( unsigned int id, bool loopFlag, f32 interpFrame, f32 stepFrame);

  //----------------------------------------------------------------------------
  /**
  *  @brief  モデルインスタンスノードを取得
  *
  *  @return モデルインスタンスノード
  */
  //-----------------------------------------------------------------------------
  gfl2::renderingengine::scenegraph::instance::ModelInstanceNode* getModelInstanceNode(void){ return m_pModelInstanceNode; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  LOD変更リクエスト
  *
  *  @param  lod          変更したいレベル
  */
  //-----------------------------------------------------------------------------
  void requestChangeLod( LOD lod ){ m_requestLod = lod; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  LODの取得
  *
  *  @return LOD
  */
  //-----------------------------------------------------------------------------
  LOD getLod( void ){ return m_lod; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  注視するターゲットを設定する
  *
  *  @param  target 注視ターゲット
  */
  //-----------------------------------------------------------------------------
  void setInterestTarget( gfl2::math::Vector3& target ){ m_targetInterest = target; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  描画するかどうか設定
  *
  *  @param  isVisible 描画するかどうか
  */
  //-----------------------------------------------------------------------------
  void setVisible( b32 isVisible ){ m_isVisible = isVisible; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  描画するかどうか取得
  *
  *  @return 描画するかどうか
  */
  //-----------------------------------------------------------------------------
  b32 isVisible( void ){ return m_isVisible; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  モーションを更新するかどうか設定
  *
  *  @param  isAnimation モーションを更新するかどうか
  */
  //-----------------------------------------------------------------------------
  void setAnimation( b32 isAnimation ){ m_isAnimation = isAnimation; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  モーションを更新するかどうか取得
  *
  *  @return モーションを更新するかどうか
  */
  //-----------------------------------------------------------------------------
  b32 isAnimation( void ){ return m_isAnimation; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  モーションを何フレームに一回だけ更新するか設定
  *
  *  @param  モーションを何フレームに一回だけ更新するか
  */
  //-----------------------------------------------------------------------------
  void setAnimationUpdateFrame( u32 animationUpdateFrame ){ m_animationUpdateFrame = animationUpdateFrame; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  モーションを何フレームに一回だけ更新するか取得
  *
  *  @return モーションを何フレームに一回だけ更新するか
  */
  //-----------------------------------------------------------------------------
  u32  getAnimationUpdateFrame(void){ return m_animationUpdateFrame; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  注視するかどうか設定
  *
  *  @param  isInterest 注視するかどうか
  */
  //-----------------------------------------------------------------------------
  void setInterest( b32 isInterest ){ m_isInterest = isInterest; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  注視するかどうか取得
  *
  *  @return 注視するかどうか
  */
  //-----------------------------------------------------------------------------
  b32 isInterest( void ){ return m_isInterest; }

   //----------------------------------------------------------------------------
  /**
  *  @brief  Ikするかどうか設定
  *
  *  @param  isIk Ikするかどうか
  */
  //-----------------------------------------------------------------------------
  void setIk( b32 isIk ){ m_isIk = isIk; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  Ikするかどうか取得
  *
  *  @return Ikするかどうか
  */
  //-----------------------------------------------------------------------------
  b32 isIk( void ){ return m_isIk; }

  //----------------------------------------------------------------------------
  /**
  *  @brief  DynamicActorからのコールバック関数
  *
  *  @param  衝突データ
  */
  //-----------------------------------------------------------------------------
  void hitDynamicCallbackFunc(void* pUserData);

  //----------------------------------------------------------------------------
  /**
  *  @brief  StaticActorからのコールバック関数
  *
  *  @param  衝突データ
  */
  //-----------------------------------------------------------------------------
  void hitStaticCallbackFunc(void* pUserData);

  //*****************************************************************************
  // アクションコマンド関連
  //*****************************************************************************

  //----------------------------------------------------------------------------
  /**
  *  @brief  動作更新( アクションコマンドがある場合はアクションコマンド、無い場合はムーブコードを実行 )
  */
  //-----------------------------------------------------------------------------
  void updateMoveCodeOrActionCmd( void );

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンドの設定
  *
  *  @param  acmd    アクションコマンド
  */
  //-----------------------------------------------------------------------------
  void SetAcmd( Acmd acmd , gfl2::math::Quaternion qua);

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンド設定時にクリアするデータ
  */
  //----------------------------------------------------------------------------
  void setAcmdClearWork( Acmd acmd );  

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンドの強制停止
  */
  //-----------------------------------------------------------------------------
  void ClearAcmd( void );

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンドの実行が可能か？
  *
  *  @retval true    可能
  *  @retval false   不可能
  */
  //-----------------------------------------------------------------------------
  bool IsAcmdUse( void ) const ;

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンドの実行が行われたか？ (実行後1フレームを検知することに使用）
  *
  *  @retval true    実行された。
  *  @retval false   実行していない。
  *
  *  1Frameで終わるアクションコマンドが実行されていたのかを検知する為に使用。
  */
  //-----------------------------------------------------------------------------
  bool IsAcmdUsed( void ) const ;

  //----------------------------------------------------------------------------
  /**
  *  @brief  アクションコマンドの実行完了待ち
  *
  *  @retval true    完了
  *  @retval false   実行中
  */
  //-----------------------------------------------------------------------------
  bool IsAcmdEnd( void ) const ;

  //----------------------------------------------------------------------------
  /**
  *  @brief  動作ビット　ON
  *
  *  @param  bit   ビット
  */
  //-----------------------------------------------------------------------------
  void onMoveBit( MoveBit bit );

  //----------------------------------------------------------------------------
  /**
  *  @brief  動作ビット　OFF
  *
  *  @param  bit   ビット
  */
  //-----------------------------------------------------------------------------
  void offMoveBit( MoveBit bit );

  //----------------------------------------------------------------------------
  /**
  *  @brief  動作ビット　チェック
  *
  *  @param  bit   ビット
  */
  //-----------------------------------------------------------------------------
  bool CheckMoveBit( MoveBit bit) const;  

  //----------------------------------------------------------------------------
  /**
  *  @brief  床コリジョンでのコールバック関数
  */
  //-----------------------------------------------------------------------------
  void rayCallbackFunc(Test::FieldTest::customCollisionCallback_Intersection::HIT_DATA* pHitData);

  //----------------------------------------------------------------------------
  /**
  *  @brief  LODを更新 @todo 処理負荷計測用一時処理
  *
  *  @param  lod          変更したいレベル
  *  @return 成否
  */
  //-----------------------------------------------------------------------------
  b32  UpdateLodTest( LOD lod );

  //----------------------------------------------------------------------------
  /**
  *  @brief  指定LODに変更できるかチェックする @todo 処理負荷計測用一時処理
  *
  *  @param  lod          変更したいレベル
  *  @return 成否(同じLODでも駄目)
  */
  //-----------------------------------------------------------------------------
  b32  CheckChangeLodTest( LOD lod ) const ;

  // @todo 処理負荷計測用一時処理(ごめんなさい)、ずっと補間する
  b32 m_IsInterpLoop;

private:

  //*****************************************************************************
  // 内部関数
  //*****************************************************************************

  //----------------------------------------------------------------------------
  /**
  *  @brief  モーションを何フレームに一回だけ更新するかも考慮したステップフレームに上書き
  */
  //-----------------------------------------------------------------------------
  void updateAnimationStepFrame(void);

  //----------------------------------------------------------------------------
  /**
  *  @brief  LODを更新
  *
  *  @return 成否
  */
  //-----------------------------------------------------------------------------
  b32  UpdateLod(void);

private:

  //! コア
  MoveModelManager    *m_pManager;
  MoveModelHeader      m_Header;
  bool                 m_exists;
  FieldTransform      *m_transform;
  
  //! 状態管理
  gfl2::animation::AnimationController m_AnimationController;
  gfl2::animation::JointController     m_JointController;
  int                                  m_animeNo;               ///< 再生中のアニメーションナンバー
  b32                                  m_isRegistSceneGraph;    ///< シーングラフに自身のインスタンスノードをぶら下げるてるかどうか(トラバース処理をするかどうか)
  b32                                  m_isVisible;
  b32                                  m_isAnimation;
  b32                                  m_isInterest;
  b32                                  m_isIk;
  LOD                                  m_lod;
  LOD                                  m_requestLod;
  gfl2::math::Vector3                  m_targetInterest;
  u32                                  m_animationUpdateFrame;
  u32                                  m_animationUpdateCnt;
  f32                                  m_animationStepFrame;

  // コリジョン情報
  gfl2::math::Vector                   m_floorNormal;

  // 階層構造用
  MoveModel*  m_pParent;
  s32         m_ParentJointIndex;

  //! ムーブコード
  const MoveCodeBase    *m_MoveCode;
  MoveCodeWork           m_moveCodeWork;

  //! アクションコマンド
  b32            m_AcmdUsed;      ///< Acmd実行後、1フレーム保持される。
  u32            m_MoveBit;       ///< 動作ビット
  field::mmodel::ActionCmdBase::ActionCmdWork   m_AcmdWork;  ///< アクションコマンド動作のデータ

  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pModelResourceRootNode[LOD_MAX];
  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pMotionResourceRootNode[chara::MOTION_ID_MAX];
  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pMotionConfigResourceRootNode;
  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pMouthMotionResourceRootNode;
  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pEyeMotionResourceRootNode;
  gfl2::renderingengine::scenegraph::resource::ResourceNode              *m_pStaticCollisionResourceRootNode;
  gfl2::renderingengine::scenegraph::instance::ModelInstanceNode         *m_pModelInstanceNode;
  gfl2::renderingengine::scenegraph::instance::MotionConfigInstanceNode  *m_pMotionConfigInstanceNode;
  gfl2::collision::CollisionModel                                        *m_pStaticCollisionModel;
};


}; //end of namespace mmodel
}; //end of namespace fld
