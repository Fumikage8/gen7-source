#pragma once
//=================================================================================================
/**
 *	@file	model_rsc_manager.h
 *	@brief
 *	@author	tamada@gamefreak.co.jp
 *	@date	2014.04.24
 */
//=================================================================================================
#include "../include/chara_define.h"
#include "System/include/HeapDefine.h"
#include <types/include/gfl2_Typedef.h>

namespace gfl2{ namespace renderingengine { namespace scenegraph {
	namespace resource { class ResourceNode;		}
	namespace instance { class ModelInstanceNode;	}
}}}

//----------------------------------------------------------------------------------------
//! @brief リソース管理オブジェクトのマネージャー
//----------------------------------------------------------------------------------------
class RscManager
{
public:

	//-----------------------------------------------------------------------------
	/*
	*          内部クラス宣言(リソースアロケータ)
	*          @class GLAllocator
	*/
	//-----------------------------------------------------------------------------
	class GLResourceAllocator : public gfl2::gfx::IGLAllocator
	{
	public:
		
		//----------------------------------------------------------------------------
		/**
		*  @brief  コンストラクタ
		*/
		//-----------------------------------------------------------------------------
		GLResourceAllocator()
		{
		#if defined(GF_PLATFORM_CTR)
			// デバイスメモリ全体 仮
			gfl2::heap::HeapBase *systemHeap = gfl2::heap::Manager::GetHeapByHeapId( HEAPID_RESIDENT_DEVICE );
			fcramHeapMem = GFL_NEW_ARRAY(systemHeap) char[FCRAM_HEAMP_SIZE];
			this->fcramHeap.Initialize( (uptr)fcramHeapMem , FCRAM_HEAMP_SIZE );
		#endif
		}

		//----------------------------------------------------------------------------
		/**
		*  @brief  デストラクタ
		*/
		//-----------------------------------------------------------------------------
		virtual			~GLResourceAllocator()
		{
		#if defined(GF_PLATFORM_CTR)
			this->fcramHeap.Finalize(); 
			GFL_DELETE_ARRAY fcramHeapMem;
		#endif
		}
		
		//----------------------------------------------------------------------------
		/**
		*  @brief  メインメモリの取得
		*  @param  取得したいメモリサイズ
		*  @param  アライメント
		*  @return メモリ
		*/
		//-----------------------------------------------------------------------------
		virtual void*	SystemMemoryMalloc(u32 size, u32 alignment)
		{
		#if defined(GF_PLATFORM_CTR)
			return fcramHeap.Allocate(size, alignment);
		#else
			return malloc(size);
		#endif
		}

		//----------------------------------------------------------------------------
		/**
		*  @brief  メインメモリの解放
		*  @param  解放したいメモリのポインタ
		*/
		//-----------------------------------------------------------------------------
		virtual void	SystemMemoryFree(void* const address)
		{
		#if defined(GF_PLATFORM_CTR)
			fcramHeap.Free(address); 
		#else
			free( address );
		#endif
		}

		//----------------------------------------------------------------------------
		/**
		*  @brief  ビデオメモリの取得
		*  @param  取得したいメモリサイズ
		*  @param  アライメント
		*  @return メモリ
		*/
		//-----------------------------------------------------------------------------
		virtual void*	LocalMemoryMalloc(u32 size, u32 alignment){ return NULL; }

		//----------------------------------------------------------------------------
		/**
		*  @brief  ビデオメモリの解放
		*  @param  解放したいメモリのポインタ
		*/
		//-----------------------------------------------------------------------------
		virtual void	LocalMemoryFree(void* const address){}
		
	private:

	#if defined(GF_PLATFORM_CTR)
		static const int	FCRAM_HEAMP_SIZE = 1024*1024*4;
		char*				fcramHeapMem;
		nn::fnd::ExpHeap	fcramHeap;
	#endif

	};

	//----------------------------------------------------------------------------
	/**
	*	@brief  シングルトンインスタンスの取得
	*    
	*	@return インスタンス
	*/
	//-----------------------------------------------------------------------------
	static RscManager* RscManager::getInstance() 
	{
		static RscManager instance;
		return &instance;
	}

	//-----------------------------------------------------------------------------
	/**
	*  @brief	コンストラクタ
	*/
	//-----------------------------------------------------------------------------
	RscManager(){}

	//-----------------------------------------------------------------------------
	/**
	*  @brief	デストラクタ
	*/
	//-----------------------------------------------------------------------------
	~RscManager(){}

	//----------------------------------------------------------------------------
	/**
	*	@brief  モデルの取得関数
	*
	*	@param	id		リソースID
	*	@return モデルリソースノードのインスタンス
	*/
	//-----------------------------------------------------------------------------
	gfl2::renderingengine::scenegraph::resource::ResourceNode* GetModelResource(chara::RSC_ID id);

	//----------------------------------------------------------------------------
	/**
	*	@brief  モーションの取得関数
	*
	*	@param	id		リソースID
	*	@return モーションリソースノードのインスタンス
	*/
	//-----------------------------------------------------------------------------
	gfl2::renderingengine::scenegraph::resource::ResourceNode* GetMotionResource(chara::RSC_ID id,u32 motionId);

	//----------------------------------------------------------------------------
	/**
	*	@brief  衝突されるコリジョンの取得関数
	*
	*	@param	id		リソースID
	*	@return コリジョンリソースノードのインスタンス
	*/
	//-----------------------------------------------------------------------------
	gfl2::renderingengine::scenegraph::resource::ResourceNode* GetStaticCollisionResource(chara::RSC_ID id);

private:

	//----------------------------------------------------------------------------
	/**
	*	@brief  ファイル読み込み
	*	@param  利用するアロケータ
	*	@param  ファイルパス
	*	@return Rawデータ
	*/
	//-----------------------------------------------------------------------------
	void *ReadData( const char* pFilePath );

	GLResourceAllocator m_ResourceAllocator;
};
